## python_tip 정리
- 인스턴스의 타입을 check 할 때는 `isinstance` 함수를 응용하자
- f-문자열에서 `:<5`는 공백 5칸 추가, `.2f`는 소수점 2째자리 수
- `sort` 함수에 `key=dict.key` 가 들어가는 것은 딕셔너리의 value로 name을 sorting 하겠다는 의미
- `__next__`는 iteration의 순서를 결정짓는 메소드, `__iter__`는 제너레이터를 정의하는 메소드
- `__missing__` 메서드는 딕셔너리에서 키가 없을 때 특정 로직을 처리할 수 있게끔 해주는 함수
- `try/except/else` 를 잘 활용해서 사용하자
- 함수에 파라미터로 입력된 mutable들은 참조 형태로 들어가므로, 항상 입력된 변수의 mutable variable이 생김 
- `__call__(self, x)` 에서 x는 클래스가 객체 인스턴스로 호출시에 입력받을 파라미터
- 변수 위치 인자: 함수에서 위치 기반 인자를 말함, <-> 키워드 인자
- 함수 파라미터에서 가변인자(*)는 아예 입력을 하지 않아도 됨
- 가변 인자(*)가 함수에 전달 될 때는 항상 튜플로 한번 변환된 후에 적용됨. 이는 메모리 소비가 많아짐
- *args의 문제점은 함수에 새로운 위치 인자를 추가하면 해당 함수를 호출하는 모든 코드를 변경해야 함
- 키워드 인자를 통한 defualt를 활용하면, 함수 호출 부분의 수정없이 결과값을 변경할 수 있음
- 함수의 키워드 인자의 default 값은 함수가 정의되는 시점 한 번만 호출됨
- 디폴트 인자 값으로 None 사용해야 할 때는 `def decode(data, default={})`임
- 위치로만 인자를 지정하게 하거나 키워드로만 인자를 지정하게 하여 함수 호출을 명확하게 만들라  
  - * 기호를 사용하여 * 기준으로 뒤에는 반드시 키워드 인자를 사용하도록 수정됨(앞에 위치 인자는 키워드/위치 둘다 사용 가능)  
  - / 기호를 사용하여 /를 기준으로 앞에는 반드시 위치 인자만 사용해야함(키워드 인자 안됨)
  - /와 * 기호 사이에 있는 파라미터는 위치를 사용해 전달할 수 있고, 이름을 키워드로 사용해 전달할 수도 있음
  - `Wrapper` 함수에 `functions.wrap` 데코레이터를 사용해서 Wrapper를 데코레이터를 사용하는 함수의 메타데이터를 정상적이게 출력되도록 할 수 있음 
  - 인트로스펙션(introspection)은 특정 클래스가 어떤 클래스에서 파생되었는지, 혹은 어떤 함수가 구현되어 있는지, 객체에는 어떤 속성이 있는지에 대한 상세한 정보를 <b>런타임</b>에 얻거나 조작하는 기술
- 제너레이터는 함수가 점진적으로 반환하는 값으로 이루어진 스트림을 만들어줌
- 컴프리헨션 값 부분에서 왈러스 연산자를 사용할 때 그 값에 대한 조건 부분이 없다면, 루프 밖 영역으로 루프 변수가 누출됨. for loop 변수 누출도 마찬가지로 일어남
- assignment expression 이란 대입식이라고도 하며, 조건문 등에서 변수를 선언해서 재활용할 수 있는 구조를 말하며, 왈러스 연산자(`:=`)를 통해 사용
- 이미 소진된 제너레이터에 대해서 이터레이터를 수행해도 아무 오류가 발생하지 않음  
  for 루프, 리스트 생성자, 그 외에 많음 파이썬에 존재하는 표준 라이브러리에 있는 많은 함수가 일반적인 연산 도중에 StopIteration이 던져지는 것을 가정하기 때문
- iterator를 여러번 이터레이션이 필요할 때, <b>이터레이터 프로토콜을 구현한 컨테이너 클래스를 제공해라</b>
- `iterator`: 순차적으로 다음 데이터를 리턴할 수 있는 객체
- `iterable`: 이터레이터를 리턴할 수 있는 객체
- 파이썬의 for roop나 그의 연관된 식이 컨테이너 타입의 내용을 방문할 때 사용하는 절차
  - `for x in foo`라는 구문을 사용
  - `foo -> iter(foo)`를 호출
  - `iter` 함수는 내부적으로 `foo.__iter__` 특별 메서드를 호출
  - `__iter__` 함수는 반드시 iterator 객체를 반환해야 함 
  - for 루프는 반환받은 이터레이터가 객체를 소진할 때까지 반복적으로 이터레이터 객체에 대해 `next` 내장 함수를 호출
- 파이썬의 이터레이터 프로토콜은 컨테이너와 이터레이터가 `iter`, `next` 내장 함수나 for 루프 등의 관련 식과 상호작용하는 절차를 정의
- `__iter__` 메서드를 제너레이터로 정의하면, 쉽게 이터러블 컨테이너 타입을 정의할 수 있음
- 어떤 값이 이터레이터인지 감지하려면, 이 값을 iter 내장 함수에 넘겨서 반환하는 값이 원래 값과 같은지 확인하면 됨 
  - `collections.abc.Iterator -> isinstacne(value, Iterator)`
  - `iter(value) is value`
- <b>제너레이터 식(generator expression)</b>은 리스트 컴프리헨션과 제너레이터를 일반화한 것. 제너레이터 식을 실행해도 출력 시퀀스 전체가 실체화되지 않음
- `yield from`을 사용하는 것이 각 제너레이터의 출력을 내보내는 것보다 성능적으로 더 좋음
- `send` 메서드를 사용하면, 입력을 제너레이터에 스트리밍하는 동시에 출력을 내보낼 수 있음
- 일반적으로 yield 값이 반환하는 값은 None `received = yield 1` --> None
- `throw` -> 호출되면 제너레이터는 값을 내놓은 yield로 부터 평소처럼 제너레이터 실행을 계속하는 대신, `throw`가 제공한 `Exception`을 다시 던짐  
- `throw`를 통해 코드를 구현하는 것보다 이터러블 컨테이너 객체를 사용해 상태가 있는 클로저를 구현  
  이터러블 클래스를 사용해서 `__iter__`를 구현하는 것이 더 좋음
- FIFO는 `deque(데크)`, indexing은 `bisect_left`를 사용하자  
  `deque`에서 `pop(0)`은 상수시간만큼 소요되며, `bisect_left`는 log 복잡도만큼 소요됨
- 원소가 들어있는 리스트에 대해 우선순위 큐를 효율적으로 구현하는 내장 `heapq` 모듈 제공
- 