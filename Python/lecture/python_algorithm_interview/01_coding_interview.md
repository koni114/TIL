## chapter02 프로그래밍 언어 선택
- 제네릭이란 파라미터의 타입이 나중에 지정되게 해서 재활용성을 높일 수 있는 프로그래밍 스타일
- 파이썬은 동적 타입 언어이기 때문에 제네릭이 필요 없음. 하지만 동적 타이핑의 장점이자 단점은 얼핏 사용하기엔 매우 편하지만 코드의 복잡도가 높아질수록 혼란을 가중시킨다는 점
- 타입을 아예 명시하지 않으면 가독성을 낮추고 버그 발생 확률이 높아짐
- PEP는 Python Enhancement Proposal의 약자
- 파이썬에서는 구조체가 없을 뿐더러 클래스 또한 데이터 타입을 지정할 수 없어, 구조체와 같은 형태를 정의하려면 namedtuple 을 사용해야 헀음. 하지만 파이썬 3.7부터 dataclass를 지원하며 @dataclass 데코레이션으로 타입 힌트와 함께 활용함으로써 다음과 같이 class를 이용해 구조체 형태로 정의할 수 있음

### 원시 타입(primitive type)  
- C나 자바 같은 프로그래밍 언어들은 기본적으로 원시 타입(primitive type)을 제공
- C 언어는 동일한 정수형이라도 크기나 부호에 따라 매우 다양한 원시 타입을 제공  
ex) short, long, long long, float, double, unsigned int 등
- 원시 타입은 메모리에 정확하게 타입의 크기만큼의 공간을 할당하고, 그 공간을 오로지 값으로 채워넣음
- 물리 메모리에 자료형의 크기만큼 공간을 갖는 요소가 연속된 순서로 배치되는 형태가 됨
- C 뿐만 아니라 자바도 마찬가지임. 원시 타입을 제공하며 매우 빠른 연산이 가능
- 자바는 primitive type과 대응되는 클래스 객체를 지원하는데 원시 타입과 대응되는 객체를 갖고 있으며 원시 타입을 객체로 변환하면 여러 가지 작업을 수행할 수 있게 됨
- 단순히 메모리에 숫자만 보관하고 있을 때는 하지 못했던 일들이 객체로 만들면 가능해지는 것임
- 대표적으로 문자 변환, 16진수 변환, shifting과 같은 비트 조작도 지원 
- 당연히 이를 위한 여러 가지 부가정보가 추가되므로, 메모리 점유율이 늘어나고 당연히 계산 속도 또한 감소함
- 자바의 int 타입은 32비트인데 반해 JOL(Java Object Layout) 실행 결과를 확인해보면 객체 Integer는 128비트나 됨. 단순히 비교해봐도 4배의 공간을 더 차지함
- 파이썬은 원시 타입을 지원하지 않음. 파이썬은 애초에 편리한 기능 제공에 우선순위를 둔 언어
- 파이썬은 모든 것이 객체며, 이 중에서 크게 immutable object와 mutable object로 구분할 수 있음
- 다음은 불변 객체와 가변 객체 구분
  - bool, int, float, tuple, str --> 불변 객체
  - list, set, dict --> 가변 객체
- 모든 것이 객체라는 것은 `a=b` 라는 식에서 a와 b는 객체라 같은 주소값을 참조하지만, 만약 원시 타입이라면 a와 b는 각각 다른 메모리의 영역에 위치함
- dict나 set의 키 값은 불변 객체만 가능

### 속도 
- 파이썬의 문제는 속도
- 단순히 정수형의 덧셈 연산을 하는 경우에도 메모리에서 값을 꺼내 한번 연산하면 끝인 원시 타입에 비해 파이썬의 객체는 값을 꺼내는 데만 해도 var -> PyObject_HEAD에서 타입코드를 찾는 등 여러 단계의 부가 작업이 필요함
- 속도를 개선하기 위해서는 numpy package를 활용해 적용하는 것이 좋음
- 예를 들어 100만 개의 대해 표준편차를 구하는 코드를 작성해 각각 100번씩 돌려 보면, 약 한 40배 정도의 차이가 남

### 자료구조, 자료형, 추상 자료형
- 자료구조란 데이터에 효율적으로 접근하고 조작하기 위한 데이터의 조직, 관리, 저장 구조를 말함
- 자료형은 컴파일러나 인터프리터에게 프로그래머가 데이터를 어떻게 사용하는지를 알려주는 일종의 데이터 속성(attribute)임
- 자료형은 자료구조에 비해서 훨씬더 구체적이고, 특정 언어에서 자료형이라고 함은 정수(Integer), 실수(Floating-Point Number), 문자열(String) 등 해당 언어에서 지원하는 원시 자료형(Primitive Data Type)까지 포함하는 모든 자료의 유형을 말함
- ADT는 자료형에 대한 수학적 모델을 지칭함. 즉 자료에 대한 연산들을 명기한 것  
  OOP에서 추상화를 떠올리면 이해하기 쉬움

### 리스트
- 리스트는 순서대로 저장하는 시퀀스, 변경 가능한 목록(Mutable List)를 말함
- 입력 순서가 유지되고, 내부적으로는 동적 배열로 구현되어 있음
- 다음은 리스트의 기능 중 O(1)만큼 걸리는 작업들
  - `len(a)`, `a[i]`, `a.append(n)`, `a.pop()`
- 다음은 리스트의 기능 중 O(n)만큼 걸리는 작업들
  - `elem in a`, `a.index(elem)`, `a.pop(0)`(전체 복사가 필요함), `del a[i]`, `min, max`, `a.reverse()`
- 큐의 연산을 사용하려면 list보다는 deque을 사용하는 것이 좋음
- 리스트는 객체로 되어 있는 자료형을 포인터로 연결
- 파이썬은 모든 것은 객체며, 파이썬의 리스트는 객체에 대한 포인터 목록을 관리하는 형태로 구현
- 연결 리스트에 대한 포인터 목록을 배열 형태로 관리하고 있으며, 그 덕분에 파이썬의 리스트는 배열과 연결 리스트를 합친 듯이 강력한 기능을 제공

### 딕셔너리
- 키/값 구조로 구현된 딕셔너리를 말함
- 파이썬 3.7+ 이상부터는 순서가 유지되며, 내부적으로는 해시 테이블로 구현되어 있음
- 파이썬은 해시할 수만 있다면 숫자 뿐만 아니라 문자, 집합까지 불변 객체를 모두 키로 사용 가능
- 이 과정을 해싱이라고 하며, 해시 테이블을 이용해 자료를 저장함
- 해시 테이블은 다양한 타입을 키로 지원하면서도 입력과 조회 모두 O(1)에 가능함
- 최악의 경우는 O(n)이 걸릴 수 있으나, 분할 상환 분석에 따른 시간 복잡도는 O(1)만큼 걸림
- 해시 테이블의 주요 연산의 시간 복잡도는 다음과 같음
  - `len(a)` : O(1)
  - `a[key]` : O(1)
  - `a[key] = value` : O(1)
  - `key in a` : O(1) 
- 파이썬 3.6이하에서는 딕셔너리의 순서가 유지되지 않아 `collections.orderedDict()`를 사용
- 3.7부터는 내부적으로 인덱스를 이용해 입력 순서를 유지하도록 개선됨
- 3.6부터는 딕셔너리 메모리 사용량 20% 감소
- Key가 존재하지 않는 경우, error 발생. 다음과 같이 처리 필요
~~~python
try:
    print(a[key])
except KeyError:
    print("존재하지 않는 키")
~~~
- `defaultdict`, `Counter`, `OrderedDict`

### 문자열
- 파이썬에서는 문자열 슬라이싱이라는 매우 편리한 기능을 제공. 무엇보다 내부적으로 매우 빠르게 동작함
- 위치를 지정하면 해당 위치의 배열 포인터를 얻게 되며 이를 통해 연결된 객체를 찾아 실제 값을 찾아냄
- 이 과정은 매우 빠르게 진행되므로 문자열을 조작할 때는 항상 슬라이싱을 우선으로 사용하는 편이 속도 개선에 유리
- 문자열을 별도로 리스트로 매핑하는 등의 처리는 데이터 구조를 다루는 입장에서는 좋은 방법이지만, 별도 자료형으로 매핑하는 과정에서 상당한 연산 비용이 필요하므로 전체적인 속도에서는 오히려 손해를 볼 수 있음
- 대부분의 문자열 작업은 슬라이싱으로 처리하는 편이 가장 빠름
- 슬라이싱을 기준으로 한 파이썬 문자열 처리 시간
  - 슬라이싱 1
  - 리스트 reverse 5
  - reversed() + join() 6
  - for 반복 12
  - while 반복 21
  - 재귀 54 

## 용어 정리
- 서브 루틴: 프로그램의 일부분을 담당하는 부분 프로그램