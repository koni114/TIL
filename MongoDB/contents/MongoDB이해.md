# MongoDB 간단 이해
## NoSQL 데이터베이스란? 
- 개발의 용이성, 기능성 및 확장성을 널리 인정받고 있음
- 데이터의 엑세스 및 관리를 위해 다양한 데이터 모델을 사용
- 이러한 데이터베이스 유형은 큰 데이터 볼륨, 짧은 지연 시간과 유연한 데이터 모델이 필요한 애플리케이션에 최적화
- 관계형 모델은 중복성을 줄이도록 정규화되는 반면, 레코드는 보통 JSON 문서로 저장됨. 관계형 데이터베이스에서 정규화되어 별도의 테이블에 각각 저장되고, 관계가 primary key 또는 foreign key로 정의되지만 NoSQL은 모든 attribute에 대해 하나의 JSON으로 만들어 document에 저장

## NoSQL 데이터베이스 유형
- 다양한 유형이 존재
  - document store 또는 document database
  - wide column store 또는 wide column database
  - In-memory database
  - key-value store 또는 key-value database
  - graph database

## SQL(관계형) vs NoSQL(비관계형) 데이터베이스 비교
- NoSQL은 비관계형과 같은 의미로 사용
- NoSQL 데이터베이스는 낮은 지연 시간의 애플리케이션을 포함한 수많은 데이터 액세스 패턴에 맞도록 설계됨
- NoSQL 검색 데이터베이스는 반정형 데이터에서 분석을 위해 설계됨
- NoSQL DB는 분산형 아키텍처를 사용해 엑세스 패턴이 확장 가능하기 때문에 분할성이 있음

## MongoDB
- BigData를 저장하기에 적합한 데이터베이스
- 솔루션 자체적으로 분산 처리, 샤딩, 데이터 리벨런싱, 데이터 복제, 복구 등을 지원하고 무엇보다 Schema-Free(Schema-less)한 구조이기에 대용량의 데이터 작업에 아주 효율적인 DB
- 일부 RDBMS의 기능을 제공하기도 함(인덱싱 등, 내부적으로 B-Tree 자료구조를 이용하여 인덱스를 관리)  
- 스키마 프리는 테이블의 컬럼 수준에만 적용되는데, 사용할 컬럼을 미리 정의하지 않고 언제든지 동적으로 필요한 시점에 데이터를 저장할 수 있다는 것을 의미

## MongoDB vs RDBMS
![img](https://github.com/koni114/Data-engineering/blob/master/img/mongo_01.JPG)
- MongoDB는 쿼리의 결과로 커서를 반환하는데, 응용 프로그램이나 MongoDB 클라이언트 프로그램에서 커서를 통해 반복적으로 실제 도큐먼트를 가져올 수 있음

## MongoDB 특징
- Document-oriented storage : MongoDB는 database > collections > documents 구조로 document는 key-value형태의 BSON(Binary JSON)으로 되어있다.
- Full Index Support : 다양한 인덱싱을 제공한다.
- Single Field Indexes : 기본적인 인덱스 타입
- Compound Indexes : RDBMS의 복합인덱스 같은 거
- Multikey Indexes : Array에 미챙되는 값이 하나라도 있으면 인덱스에 추가하는 멀티키 인덱스
- Geospatial Indexes and Queries : 위치기반 인덱스와 쿼리
- Text Indexes : String에도 인덱싱이 가능
- Hashed Index : Btree 인덱스가 아닌 Hash 타입의 인덱스도 사용 가능
- Replication& High Availability : 간단한 설정만으로도 데이터 복제를 지원. 가용성 향상.
- Auto-Sharding : MongoDB는 처음부터 자동으로 데이터를 분산하여 저장하며, 하나의 컬렉션처럼 사용할 수 있게 해준다. 수평적 확장 가능
- Querying(documented-based query) : 다양한 종류의 쿼리문 지원. (필터링, 수집, 정렬, 정규표현식 등)
- Fast In-Pace Updates : 고성능의 atomic operation을 지원
- Map/Reduce : 맵리듀스를 지원.(map과 reduce 함수의 조합을 통해 분산/병렬 시스템 운용 지원, 하둡처럼 MR전용시스템에 비해서는 성능이 떨어진다)
- GridFS : 분산파일 저장을 MongoDB가 자동으로 해준다. 실제 파일이 어디에 저장되어 있는지 신경 쓸 필요가 없고 복구도 자동이다.
- Commercial Support : 10gen에서 관리하는 오픈소스

### MongoDB 장점
- Flexibility : Schema-less라서 어떤 형태의 데이터라도 저장할 수 있다.
- Performance : Read & Write 성능이 뛰어나다. 캐싱이나 많은 트래픽을 감당할 때 써도 좋다.
- Scalability : 애초부터 스케일아웃 구조를 채택해서 쉽게 운용가능하다. Auto sharding 지원
- Deep Query ability : 문서지향적 Query Language 를 사용하여 SQL 만큼 강력한 Query 성능을 제공한다.
- Conversion / Mapping : JSON형태로 저장이 가능해서 직관적이고 개발이 편리하다.

## MongoDB 단점
- JOIN이 없다. join이 필요없도록 데이터 구조화 필요
- memory mapped file으로 파일 엔진 DB이다. 메모리 관리를 OS에게 위임한다. 
- 메모리에 의존적, 메모리 크기가 성능을 좌우한다. 2-4를 참고하자.
- SQL을 완전히 이전할 수는 없다.
- B트리 인덱스를 사용하여 인덱스를 생성하는데, B트리는 크기가 커질수록 새로운 데이터를 입력하거나 삭제할 때 성능이 저하된다. 이런 B트리의 특성 때문에 데이터를 넣어두면 변하지않고 정보를 조회하는 데에 적합하다.

## MongoDB의 Physical 데이터 저장 구조 
- MongoDB 구성시, 가장 많이 이슈되는 부분 중 하나가 메모리량과 디스크 성능
- 메모리 크기가 아주 민감한 요인이 됨
- MongoDB는 기본적으로 memory mapped file을 사용. 데이터를 쓰기할 때, 디스크에 바로 쓰기작업을 하는 것이 아니라 논리적으로 memory 공간에 쓰기를 하고 일정 주기에 따라서 이 메모리 block들을 주기적으로 디스크에 쓰기함
- 이 디스크 쓰기 작업은 OS에 의해서 이루어짐
- OS에 의해서 제공되는 가상 메모리를 사용하게 되는데 , 물리 메모리 양이 작더라도 가상 메모리는 훨씬 큰 공간을 가질 수 있음
- 가상 메모리는 Page라는 블럭 단위로 나뉘어 지고, 이 블럭들은 디스크 블럭에 매핑되고 이 블럭들의 집합이 하나의 데이터 파일이 됨
![img](https://github.com/koni114/Data-engineering/blob/master/img/mongo_02.JPG)
- 메모리에 저장되는 내용은 실제 데이터 블록과, 인덱스 자체가 저장됨
- MongoDB에서 인덱스를 남용하지 말라는 이야기가 있는데, 이는 인덱스를 생성 및 업데이트하는데 자원이 들어갈 뿐더러, 인덱스가 메모리에 상주하고 있어야 제대로 된 성능을 낼 수 있기 때문이기도 함
- 만약 물리 메모리에 해당 데이터 블록이 없다면, page fault가 발생하게 되고, 디스크에서 그 데이터 블록을 로드하게 됨
- page fault가 발생하게 되면 page를 메모리와 disk 사이에 스위칭하는 현상이 일어나기 때문에 디스크IO가 발생하고, 오버헤드를 유발하게 됨
- 즉 메모리 용량을 최대한 크게 해서 page fault를 예방하라는 이야기인데, page fault가 아예 발생 안 할수는 없음(1TB의 데이터를 위해 메모리를 진짜 1TB만큼 올릴 수는 없기 때문)
- 그래서 page fault를 최대한 줄이는 전략으로 접근하는 방법이 옳은 방법
- <b>결과적으로 자주 엑세스 되는 데이터(Hot Data)가 집중되서 메모리에 올라가도록 key 설계를 하는 것이 핵심</b>
- 전체 데이터를 scan하는 등의 작업을 하게 되면 무조건 page fault가 발생하기에 <b>table scan이 필요한 시나리오는 별도의 index table을 만들어서 사용하는 등의 전략이 필요</b>

## MongoDB 배포 형태별 아키텍처
### 단일 노드
- 단일 노드로 MongoDB를 사용할 때에는 아무런 관리용 컴포넌트도 필요하지 않음
- 클라이언트는 MongoDB 클라이언트 드라이버와 통신하며, MongoDB 클라이언트 드라이버는 1:1로 MongoDB 서버와 통신

### 단일 레플리카 셋
- 레플리카 셋은 특정 서버에 장애가 발생했을 때, 자동 복구를 위한 최소 단위이므로 자동 복구가 필요하다면 항상 레플리카 셋으로 배포해야 함
- MongoDB 클라이언트 드라이버는 직접 MongoDB 서버로 접속하지만, 단일 노드로 접속할 때와 달리 레플리카 셋 옵션을 사용해야 함
- 하나의 레플리카 셋에는 항상 하나의 프라이머리 노드와 1개 이상의 세컨드리 노드로 구성되며 프라이머리 노드는 사용자의 데이터 변경 요청을 받아 처리하고, 세컨드리 노드는 프라이머리 노드로부터 변경 내용을 전달받아 서로의 데이터를 동기화함
- 읽기 쿼리는 프라이머리 노드 뿐만 아니라 필요하면 세컨드리 노드로 요청할 수 있음
- MongoDB 레플리카 셋은 항상 레플리카 셋에 포함된 노드 간 투표를 통하여 프라이머리 노드를 결정하므로 가능하면 홀수 개의 노드로 구성하는 것이 좋음
- 짝수 개의 노드로도 구성할 수 있지만, 실제 홀수로 구성한 것과 가용성이 다르지 않으며, 오히려 하나의 노드가 낭비됨
- 하지만 이런 생각을 할 수 있다. "레플리카 셋을 굳이 3대의 서버로 구축하는 것은 때로는 서버의 낭비일 수 있지 않은가?" 
- 이런 경우를 위하여 MongoDB 서버를 아비터 모드로 실행할 수 있음
- 아비터 모드로 시작되면 레플리카 셋의 노드들과 heartbeat만 주고 받으며, 프라이머리 노드가 불능일 때, 아비터 모드가 아닌 세컨드리 노드 중 프라이머리 노드의 선출을 위한 투표에만 참여
- 아비터는 로컬 디스크에 데이터를 저장하지 않고 프라이머리부터 데이터를 주고 받지 않기 때문에 고 사양의 장비도 필요하지 않음
- 또한 아비터는 데이터를 가지고 있지 않으므로, 세컨더리로 선출될 수도 없음
- 하나의 레플리카 셋에 여러개의 아비터 노드가 존재할 수는 있지만, 실제 정상적인 상태에서 하나 이상의 아비터는 필요하지 않음

### 샤딩된 클러스터
- 샤딩된 클러스터 구조에서는 하나 이상의 레플리카 셋이 필요하며, 각 레플리카 셋은 자신만의 파티션된 데이터를 가지게 됨  
ex) 예를 들면 전체 데이터가 6이고, 레플리카 셋이 3개라면 각각 2의 데이터 파티션을 나누어 가짐
- 샤딩된 클러스터에 참여하고 있는 각각의 레플리카 셋을 샤드라고 하는데, 이 샤드들이 어떤 데이터를 가지는지에 대한 정보는 MongoDB Config 서버가 관리
- 샤딩된 클러스터 구조에서는 위의 2가지 상황과 달리 MongoDB 클라이언트 드라이버가 직접 서버에 붙지 않고 MongoDB 라우터에 연결됨
- 그리고 라우터는 자동으로 MongoDB config 서버로부터 각 샤드가 가지고 있는 데이터에 대한 메타 정보들을 참조하여 쿼리를 실행함
- 말 그대로 라우터는 사용자로부터 요청된 쿼리를 실제 데이터를 가지고 있는 샤드로 전달하는 역할을 수행
- 이뿐만 아니라 라우터는 사용자를 대신하여 모든 샤드로부터 쿼리를 요청하고 결과를 정렬 및 병합하여 반환하는 처리도 수행
- 라우터는 각 샤드간의 데이터가 재분배되는 시점에도 동일한 역할을 수행하여 사용자나 응용 프로그램이 알아채지 못하게 투명하게 데이터 리벨런싱 작업을 처리

## 용어 정리
- 스키마
  - DB 구조와 제약조건에 관해 전반적인 명세를 기술한 것
- 인덱스(index)
  - 추가적인 쓰기 작업과 저장 공간을 활용하여 DB Table의 검색 속도를 향상시키기 위한 자료구조
  - DB의 index는 책의 색인과 같음 
  - 참고 블로그 : https://mangkyu.tistory.com/96
- 레플리카 셋(Replica set)
  - Replication set의 약자로서 문자 그대로 '복제 셋'임. 즉 DB를 복제해서 사용함
  - 참조 블로그 : https://m.blog.naver.com/PostView.nhn?blogId=dlghks44&logNo=221314300059&proxyReferer=https:%2F%2Fwww.google.com%2F
- 아비터
  - 데이터를 저장하지 않고 투표만 하는 노드 
- 샤딩
  - 같은 테이블 스키마를 가진 데이터를 다수의 DB에 분산하여 저장하는 방법을 의미
  - Horizontal partitioning이라고 볼 수 있음 