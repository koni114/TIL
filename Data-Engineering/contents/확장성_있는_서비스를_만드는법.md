# 확장성 있는 서비스를 만드는 법
- 시스템 디자인은 엔지니어로서 성장하기 위해 꼭 공부가 필요한 과목
- 실리콘벨리식 엔지니어링 면접에서는 주니어 이상의 면접에 꼭 들어감
- 면접에서는 "넷플릭스의 컨텐츠 딜리버리 시스템을 설계해보아라.", "구글의 웹 크롤러를 설계해보아라" 등의 처음 준비 없이 들으면 막연한 문제들을 던짐
- 엔지니어링 리더들은 시스템 디자인의 달인이어야 하며 어떤 서비스던 효율적으로 설계하고 설계에 고려된 여러 트레이드오프를 설명할 수 있어야 함
- 하지만 대부분이 실무적인 경험에 의해 전달되기 때문에 혼자선 공부하기 힘든 경우가 많음

## 시스템 디자인이란? 
- 엔지니어링은 "How"와 "When"을 책임짐. 제품의 전반적인 요구사항을 같이 고민하기도 하겠지만, 이 제품을 "어떻게" 구현하고 "언제까지" 구현할지는 엔지니어의 영역
- 엔지니어는 제품 사양을 "어떻게" 구현할까를 고민하는데, 여기서 시스템 디자인을 고민하게 됨
- 시스템 디자인은 요구사항을 맞추기 위해 최적화된 아키텍처, 인터페이스, 데이터 모델 등을 정의하는 과정을 뜻함
- 제품의 요구사항이 파악되고 나면 시스템을 이룰 기술사양을 작성하는 과정이라고 보면 됨
- 좋은 시스템 디자인은 제품의 특성을 파악하여 매끄러운 운영과 확장을 가능케 함. 프론트 / 백엔드에서 모두 시스템 디자인을 고려하지만, 특히 확장성을 더욱 고려해야 하는 백엔드와 데이터 엔지니어링에 필수임
- 실리콘벨리의 거의 대부분의 회사들은 시스템 디자인을 회사의 제품 설계 필수 과정으로 두고 있음
- PRD(Product Requirement Document) 즉, 제품 사양서를 PM이 주도하여 엔지니어, 디자이너 등이 참여하여 작성하고나면 엔지니어 주도하에 ERD(Engineering Requirement Document)가 작성됨
- ERD는 제품의 기술적인 설계도이며, 여러 팀의 엔지니어가 참여해 작성하게 됨. ERD가 바로 시스템 디자인이라고 보면 됨
- ERD는 실무에 중요하게 쓰이기 때문에 실리콘 벨리 기술기업들의 인터뷰 과정에서도 꼭 들어가 있는 필수 공부 과목임  
  엔지니어의 레벨이 올라가면서 점점 면접에서 차지하는 비중이 커짐. 하지만 시스템 디자인을 알려주는 자료가 거의 없어 글로 배우기에는 한계가 있고 실무 경험을 바탕으로 쌓이게 됨
- 시스템 디자인은 엔지니어가 거의 평생에 걸쳐 공부해야 하는 과목 중에 하나. 그만큼 배울 것이 많고 실무에서는 정답이 존재하지 않음  
  같은 제품 사양이더라도 1000명이 쓰는 제품과 1000만명이 쓰는 제품의 시스템 디자인이 다르고 제품이 어떻게 진화할지도 다름
- 앞으로 시스템 디자인을 할 때 고려해야할 요소들을 알아보고, 여러 케이스 스터디를 보면서 실제로 시스템 디자인을 한다면 어떤식으로 적용이 되는지 알아보자

## 시스템 디자인 기초
- 시스템의 확장성, 신뢰성, 안정성, 성능, 그리고 일관성과 관련된 요구사항을 만족시키기 위해 쓰이는 여러가지 방법이 있음
- 시스템 디자인을 하며 나오는 여러 종류의 방법과 고려해야 할 요소들을 먼저 간단하게 알아보자

### 분산화 시스템 
- 분산화 시스템은 크게 5가지 특징을 가짐. 시스템을 분산하는 이유에 따라 한가지 특징이 다른 특징보다 더욱 강조되기도 함
  - 확장성(Scalability) : 분산화 시스템은 트래픽이 늘어남에 따라 수평적 확장이 가능함
  - 신뢰성(Scalability) : 신뢰성은 특정 기간동안 시스템이 장애를 겪을 확률로 계산함. 분산화 시스템에서 신뢰성을 이루기 위해 한가지 컴포넌트가 망가지더라도 계속 응답을 줄 수 있어야 함
  - 가용성(Availability) : 언제든 시스템이 요청을 받아 응답을 내놓을 수 있어야함. 시스템이 신뢰성이 있다면 가용성이 있다는 말과 같음. 하지만 가용성이 있다고 신뢰성이 있다고 말할수는 없음
  - 성능/효율성(Efficiency) : 성능은 크게 응답에 걸리는 시간(레이턴시, Latency)와 네트워크 출력(throughput)으로 측정할 수 있음. 많은 분산화 시스템은 만족할만한 레이턴시를 유지하면서 스루풋을 키움
  - 관리 용이성(Manageability) : 시스템을 분산화 시켜 복잡도가 올라가더라도 관리하기가 용이해야 함. 시스템을 지속적으로 모니터링 하고 장애가 날 경우 빠르게 복구할 수 있어야함

### 수평적 확장
- 수평적 확장성이란 제품의 요구사항이 늘어남에 따라 노드를 추가하는 식으로 확장할 수 있는 경우를 말함
- 로드 벨런싱을 적용하여 트래픽이 균일하게 분산되도록 할 수 있으며, 트래픽이 많아진다면 노드를 추가하여 다른 노드들의 일을 줄일 수 있음
- 하나의 노드가 망가지게 된다면 트래픽은 다른 노드들로 트래픽을 돌릴 수 있음
- 하지만 여러 노드에 데이터가 분산되어 있기 때문에 데이터의 일관성이 떨어질 수 있음

### 수직적 확장
- 수직적 확장이란 하나의 노드를 두고 성능을 최적화하여 반응속도와 처리량을 높이는 것을 말함 
- 로드벨런싱 같은 여러 단계를 거치지 않기 때문에 네트워킹 속도가 더 빠르고 데이터를 처리하는 곳이 하나이기 때문에 일관성이 있지만 이 하나의 노드가 망가지면 모든 시스템이 망가지는 것이기 때문에 안정성이 높지 않음
- 그리고 하드웨어의 한계로 확장성의 한계도 있음

### 모노리스
- 모노리스는 단일 어플리케이션의 형태
- 모노리스 아키텍처는 복잡하지 않은 작은 시스템과 팀에 유리함
- 단일 어플리케이션에서 모든 것을 처리하기 때문에 네트워크 콜이 최소화되어 시스템의 레이턴시 성능이 중요한 경우 쓰일 수 있음
- 하지만 이 시스템을 관리하는 팀이 늘어나거나 시스템 자체가 복잡해지면 관리하기가 힘들어짐

### 마이크로서비스
- 모노리스와는 다르게 한가지에 특화된 모듈 여러개로 시스템을 구성하는 것
- 모듈들이 간단하고 한가지 일을 하기 때문에 테스트 하기 편함
- 그리고 모듈들을 따로 분리해 배포할 수 있어 복잡한 시스템도 장애시 복구하거나 모니터링하고 관리하기가 편리함

### 로드 벨런싱
- 로드 밸런서는 분산화 시스템에서 중요한 컴포넌트
- 트래픽을 여러 노드로 균일하게 분산하는 역할을 하며 분산이 잘 될 경우 전반적인 성능과 가용성을 높일 수 있음. 
- 노드 중 하나가 장애를 일으킨다면 요청을 다시 재분배 하게 됨 
- 로드밸런서는 유저-웹서버 사이에 둘 수도 있고 마이크로서비스 사이에 둘 수도 있음. 
- 트래픽을 분산시키기 위해 Round Robin같은 알고리즘을 쓰게 됨

### 캐싱
- 트래픽이 증가함에 따라 가장 먼저 고려하는 최적화 수단은 캐싱
- 캐싱은 하드디스크나 SSD로 가는 트래픽을 훨씬 빠른 인메모리 저장소로 보낼 수 있음
- 캐싱은 참조 지역성의 원리 (locality of reference principle)을 따르는데, 최근 요청된 데이터가 다시 요청될 확률이 높음을 뜻함. 
- 따라서 최근 요청된 데이터를 인메모리에 보관하여 다시 요청될때 빠르게 다시 응답할 수 있음
- 어플리케이션단에서 Redis와 같은 캐시를 쓸 수 있으며 이미지와 동영상을 서빙하는데 쓰이는 CDN도 캐시의 일종

### 데이터 파티션
- 파티션은 데이터를 여러개의 작은 파트로 나누는 것을 말함
- 가용성, 성능, 그리고 관리 용이성을 높이기 위해 이용되며 수평적인 확장을 가능케 함 
- 파티셔닝은 크게 수평 파티셔닝 (Horizontal Partitioning)과 수직 파티셔닝 (Vertical Partitioning), 그리고 디렉토리 기반 파티셔닝 (Directory-based Partitioning)으로 나눌 수 있음
  - 수평 파티셔닝:  행(row)을 잘라 보관하는 것을 뜻함.   
    다른 이름으로는 범위 기반 파티셔닝 (range based parititoning)이라고 함.  
    하지만 수평 파티셔닝을 잘못 쓰는 경우 데이터가 불균형하게 분산될 수 있음.  
    예를 들어 대한민국 도시의 아이디 별로 파티셔닝을 한다면 많은 데이터가 서울의 파티션에 쏠리게 될 것임
  - 수직 파티셔닝: 수직 파티셔닝은 테이블 별로 파티셔닝을 하는 것을 말함  
    예를 들어 유저, 댓글, 사진 등의 테이블이 따로 있다면 테이블 별로 파티션을 나누는 것  
    문제점은 역시 유저가 증가함에 따라 확장성이 떨어진다는 것
  - 디렉토리 기반 파티셔닝: 디렉토리 서버가 데이터베이스 앞단에 위치하게 됨.  
    데이터베이스 노드들은 고유 키 값으로 디렉토리 서버를 통해 맵핑됨

### 수평 파티셔닝과 샤딩
- 수평 파티셔닝은 스키마가 같은 데이터를 나누어 저장하는 것을 뜻하지만, 샤딩은 물리적으로 다른 데이터베이스에 데이터를 수평 파티셔닝 방식으로 분산 저장하고 조회하는 방법을 말함
- 최근의 샤딩은 인프라 플랫폼 차원에서 지원하는 경우가 많음

### 프록시
- 프록시 서버는 클라이언트와 서버 중간에 위치하여 트래픽을 미러링하는 서버
- 프록시는 양방향으로 쓰일 수 있으며, Forward Proxy 는 서버로부터 클라이언트를 익명화하는데 쓰일 수 있고, Reverse Proxy는 서버에 대한 정보를 숨기는데 사용됨
- 리버스 프록시로 외부 트래픽으로부터 내부 네트워크의 서버들을 보호할 수 있음
- 따라서 개발자들이 보안에 대한 큰 걱정 없이 개발할 수 있게 됨

### 인덱싱 
- 인덱싱은 데이터베이스를 이용할 때 이용됨. 서비스가 커지면서 언젠간 데이터베이스의 성능이 만족하지 못할만큼 느려지기 마련
- 첫 번째로 봐야하는 것이 인덱싱. 인덱싱의 목표는 데이터베이스의 데이터를 더욱 빠르게 찾기 위함
- 인덱싱은 하나 혹은 여러개의 컬럼을 이용하여 만들어질 수 있으며, 정렬된 데이터를 빠르게 찾도록 도와줌

### CAP 이론
- CAP 이론은 시스템 디자인에서 중요한 기초를 이루는 이론
- CAP 이론에 따르면 분산화된 시스템은 CAP의 앞글자를 이루는 Consistency(일관성), Availability(가용성), Partition Tolerance(분단 허용성) 3가지 중 2가지만 만족시킬 수 있음
- 시스템을 만들때는 요구사항 중 무엇이 가장 중요할지 판단하고 trade off 를 정하고 설명할 줄 알아야함
  - Consistency : 모든 노드는 같은 시간에 동일한 항목에 대하여 같은 내용의 데이터를 사용자에게 보여줌 
  - Availability: 모든 사용자들이 읽기 및 쓰기가 가능하며, 몇몇 노드의 장애에도 서비스가 유지되어야 함
  - Partition Tolerance: 메세지 전달이 실패하거나 일부 시스템이 망가져도 시스템이 계속 동작할 수 있어야 함
- CAP 이론을 데이터베이스에 적용할 경우, 
  - C와 A를 택한다면 그다지 실용성이 없음. 분산화된 시스템에선 파티션을 만들 수 밖게 없기 때문
  - 여러 지역에서 동시에 쓰여야 되는 데이터베이스일 경우 C와 P를 택할 수 있음
  - 하지만 Consistency와 Partition Tolerance를 택한다면 여러 노드의 일관성을 유지하기 위해 뒤쳐지는 노드를 정상화 될때까지 잠시 비활성화 시키고 운영함
  - NoSQL 데이터베이스인 Mongo DB가 이런 특징을 갖고 있음
  - A와 P를 택한다면 확장성을 높일 수 있지만 노드간 일관성이 떨어지는 것을 감수해야 함
  - 만약 유저가 뒤쳐지는 노드에서 데이터를 가져온다면 오래된 데이터를 받아갈 수 있음
  - Cassandra 데이터베이스의 경우 A와 P를 택했지만 Eventual Consistency, 즉 충분한 시간을 주었을때 일관성이 유지되는 아키택쳐를 채택하고 있음

### Redundancy와 Replication
- Redundancy와 Replication을 한국어로 번역하면 둘다 “복제”로 직역될 수 있음
- 하지만 소프트웨어 엔지니어링에선 조금 더 디테일 한 의미를 갖음
- 첫번째로 Redundancy란 시스템 장애상황을 대비하여 중요한 요소들을 복제하고 장애를 대비해서 여러 노드를 운영하는 것을 뜻함
- 그리고 Replication이란 서로 다른 스토리지에 같은 데이터를 갖도록 하고, 여러 노드가 항상 consistency (일관성)을 유지하도록 하는 것을 뜻함
- 시스템의 안정성과 신뢰성, 그리고 접근성을 높이기 위해 replication을 적용할 수 있음
- 여러 데이터베이스가 replication을 지원하고 있음

### 이벤트 드리븐 아키텍처(EDA)
- 마이크로서비스를 만들때 많이 쓰이는 이벤트 드리븐 아키텍쳐는 이벤트를 활용하여 여러 분리된 서비스간 통신을 하도록 구성하는 것을 말함
- 일반적인 리퀘스트 드리븐 아키텍쳐에선 서비스 A가 서비스 B에 요청을 하고, 현재의 상태(state)를 돌려받음
- 하지만 이벤트 드리븐 아키텍쳐에선 B가 직접 현재의 상태를 서비스 A로 보내게 됨
- 리퀘스트 드리븐 아키텍쳐에선 모든 마이크로 서비스가 비슷한 정도의 확장성을 지원해야 하지만, 이벤트 드리븐 아키텍쳐에선 Queue를 쓰는것과 비슷하여 이 것을 분리할 수 있음

## 좋은 시스템 디자인을 위해 고민하는 법
- 요구사항 파악
  - 오버 엔지니어링을 방지하고 어느 부분에서 확장성을 키울지 파악하기 위해 제품이 무엇을 목표로 하는지 알아내는 것이 중요함
  - 시스템을 설계할때 두가지 종류의 요건을 파악해야 하는데 첫번째는 기능적인 요건과 두번째는 기능적이지 않은 (안정성, 보안성, 확장성, 관리 용이성, 신뢰성) 요건
  - 기능적인 요건은 예를 들어 “유저가 댓글을 달 수 있어야 함"과 같이 기능에 초점을 두며, 비기능적인 요건은 시스템의 가용성이 높아야 하며, 일관성이 유지되어야 하고, 요청을 보내면 100ms 내에 응답이 와야한다는 등의 것들
- 필요 사양 예측
  - 트래픽이 얼마나 나올지 파악하고, 저장해야 될 데이터는 얼마나 될 것이며 네트워크 비용은 얼마나 나오는지 등을 고려하여 시스템의 필요 사양들을 예측
- 인터페이스 디자인
  - 주요 개체(entity)를 파악하고, 데이터의 모양을 정하고 그에 특화된 데이터베이스를 선택
  - 실제로 데이터가 어떻게 저장될지 주요 칼럼명을 작성해보고 데이터베이스 스키마를 작성
  - 마이크로서비스간 통신을 할때 API와 Event등을 설계
- 컴포넌트 설계
  - 필요 컴포넌트들을 그려봅니다. 예를 들어 분산화된 댓글 시스템을 만드려면 로드밸런서, 어플리케이션 서버, 디비, 파일 스토리지 등의 플로우를 그려봄
- 병목 고려
  - 어디서 병목 현상이 나올 수 있는지 고민하고  샤딩 / 파티셔닝 / 캐싱등을 사용하여 데이터를 어떻게 효율적으로 저장하고 빠르게 쿼리할 수 있을지 설명할 수 있어야 함
- 미래 예측
  - 비즈니스와 서비스의 요구사항이 어떻게 변할지 알아보고 어떻게 대응할 수 있을지 미리 생각함
  - 예를 들어 사용자가 기하급수적으로 늘어나거나, 필요 기능이 늘어난다던지, 새로운 서비스와의 연동은 어떻게 할지 등을 고려함