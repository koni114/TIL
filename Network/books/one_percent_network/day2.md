## day - 2
#### 리퀘스트 메세지를 보내면 응답이 되돌아온다
- 리퀘스트 메세지를 보내면 응답 메세지가 되돌아오는데, 이 때 status code 와 함께 옴. status code 는 사람에게 결과를 알려주기 위한 용도
- HTTP status code 개요  
  - 1xx : 처리의 경과 상황 등을 통지
  - 2xx : 정상 종료
  - 3xx : 무언가 다른 조치가 필요함을 나타냄
  - 4xx : 클라이언트 측의 오류
  - 5xx : 서버측의 오류
- 리퀘스트 메세지에 쓰는 URI는 한 개만으로 결정되어 있으므로, 파일을 한 번에 한 개씩만 읽을 수 있음

### 웹서버의 IP주소를 DNS서버에 조회한다
#### IP 주소의 기본
- HTTP의 메세지를 만들면 다음에는 이것을 OS에 의뢰해서 액세스 대상의 웹 서버에게 송신
- 브라우저는 URL을 해독하거나 HTTP 메세지를 만들지만, 메세지를 네트워크에 송출하는 기능은 없기 때문에 OS에 의뢰하여 송신
- 이 때, URL 안에 쓰여있는 도메인명에서 IP 주소를 조사해야함
- OS에 송신을 의뢰할 때는 도메인명이 아니라 IP 주소로 메세지를 받을 상대를 지정해야 함
- <b>TCP/IP는 서브넷이라는 작은 네트워크를 라우터로 접속하여 전체 네트워크가 만들어진다고 생각할 수 있음</b>
- 서브넷이란 허브에 몇 대의 PC가 접속된 것이라고 생각해도 무방  
  이러한 서브넷을 라우터로 연결하면 네트워크 전체가 완성됨
- 00 동 00 번지 라는 형태로 네트워크 주소를 할당하는데, 00 동에 해당하는 번호를 서브넷에 할당하고, 00 번지에 해당하는 번호를 컴퓨터에 할당  
동에 해당하는 번호를 <b>네트워크 번호</b> 라고 하며, 번지에 해당하는 번호를 호스트 번호라고 함
- 이 두 주소(네트워크 번호 + 호스트 번호)를 합쳐 IP 주소라고 함
- 통신 데이터의 받는 사람 기입란에 액세스 대상의 주소를 기입하면 라우터가 받는 사람을 보고 이것이 어느 방향에 있는지를 조사하여 그 방향으로 데이터를 중계
- 이러한 작업을 반복하여 엑세스 대상에 데이터가 도착함

![img](https://github.com/koni114/TIL/blob/master/Network/lecture/one_percent_network/img/network_04.png)

- 실제 IP 주소는 32비트의 디지털 데이터고, 8 비트씩 점으로 구분하여 10진수로 표기하는데, 이것만으로는 어디가 호스트 번호이며 네트워크 번호인지 알수 없음
- IP 주소의 규칙에서는 네트워크 번호와 호스트 번호의 두 가지를 합쳐서 32비트로 한다는 것만 결정되어 있을 뿐 내역은 결정되어 있지 않기 때문
- 이러한 내역을 나타내는 정보를 필요에 따라 IP 주소에 덧붙이는데, 이 정보를 넷마스크라고 함
- 넷마스크는 IP 주소에서 32비트 부분의 디지털 데이터이며, 왼쪽에 1이 나열되고 오른쪽에 0이 나열된 값이 됨  
0인 부분은 호스트 번호를 나타냄

![img](https://github.com/koni114/TIL/blob/master/Network/lecture/one_percent_network/img/network_05.png)

- 호스트 번호 부분이 모두 0인 IP 주소는 각각의 기기(컴퓨터)를 나타내는 것이 아니라, 서브넷 기기 자체를 나타냄
- 호스트 번호 부분이 모두 1이면 서브넷에 있는 기기 전체에 패킷을 보내는 브로드캐스트를 나타냄

#### 도메인명과 IP 주소를 구분하여 사용하는 이유
- URL 안에는 가상 호스트 기능을 사용하고 있지 않다면, 서버명이 아니라 IP 주소를 써도 올바르게 작동하는데,  
  이러한 IP 주소는 외우기가 어려우므로 서버의 이름을 쓸 수 있도록 하는 것이 좋음
- 그렇다면 왜 기억하기 어려운 IP 주소를 사용하고, 도메인명으로 네트워크 매핑을 하지 않을까? 
  - 실행 효율의 관점에서 보았을 때 좋은 방법이 아님
  - IP 주소는 32 비트이지만 도메인명은 수십 바이트 ~ 255바이트나 있기 때문에 
    라우터가 부하되어 데이터를 운반하는 동작에 더 많은 시간이 걸려 네트워크 속도가 느려짐
  - 고성능 라우터도 한계가 있음
- 이름을 알면 IP주소를 알수있고, IP주소를 알면 이름을 알 수 있게 하는 것이 DNS(Domain Name System)

#### Socket library가 IP 주소를 찾는 기능을 제공한다
- IP 주소는 가까운 DNS 서버에 서버명에 해당되는 IP 주소를 달라고 질문함
- 그러면 브라우저는 어떻게 DNS 서버를 조회할 수 있을까? 
- DNS 서버에 조회한다는 것은, DNS 서버에 request message 를 보내고, response message를 받는 것
- 이는 DNS 서버에 대해 클라이언트로 동작한다고 말할 수 있는데, DNS 클라이언트에 해당되는 것을 <b>DNS 리졸버</b> 라고 함
- DNS 원리를 사용하여 IP 주소를 조사하는 것을 네임 리졸루션이라고 함
- 리졸버의 실체는 Socket 라이브러리에 들어있는 부품화한 프로그램
- Socket 라이브러리는 OS에 포함되어 있는 네트워크의 기능을 애플리케이션에서 호출하기 위한 부품을 모아둔 것이며, 리졸버는 그 중 하나  

#### 리졸버를 이용하여 DNS 서버를 조회한다
- 브라우저 등의 애플리케이션 프로그램을 만들 때, 리졸버의 프로그램명과 웹 서버의 이름을 쓰기만 하면 리졸버를 호출할 수 있음
- 리졸버를 호출하면, 리졸버가 DNS 서버에 조회 메세지를 보내고, 응답메세지가 오는데 응답 메세지에는 IP 주소가 포함되어 있으므로   
  리졸버는 이를 추출하여 브라우저에서 지정한 메모리 영역에 써넣음
- 브라우저가 웹 서버에 메세지를 보낼 때는 이 메모리 영역에서 IP 주소를 추출하여 HTTP의 리퀘스트 메세지와 함께 OS에 건네주어 송신을 의뢰함
- <b>즉 도메인명에서 IP 주소를 조사할 때, 브라우저는 Socket 라이브러리의 리졸버를 이용</b>


#### 리졸버 내부의 작동
- 네트워크 어플리케이션(브라우저 등)이 리졸버 호출
- 제어가 리졸버로 넘어감 
- 리졸버는 DNS 서버에 문의하기 위한 request message 를 만듬  
  이는 브라우저가 웹 서버에 보내는 HTTP request message 를 만드는 것과 유사  
- 해당 메세지를 DNS 서버에 보내는데, 이 때 리졸버 자체가 하는 것이 아니라, OS의 프로토콜 스택을 호출하여 실행을 의뢰
- 제어가 리졸버에게 넘어가고 여기서 메세지를 보내는 동작을 실행하여 LAN 어댑터를 통해 메세지가 DNS 서버를 향해 송신
- DNS 서버는 메세지에 쓰여있는 답을 찾고, response message에 답을 써서 클라이언트에 반송
- 클라이언트 -> 프로토콜 스택 -> 리졸버 -> IP 주소 추출
- 리졸버 호출시  지정한 메모리 영역에 IP 주소 저장
- 리졸버의 동작이 끝나고, 제어가 애플리케이션에게 돌아옴
- DNS 서버에 메세지를 송신할 때도 DNS 서버의 IP 주소 필요


### 전세계의 DNS 서버가 연대한다
#### DNS 서버의 기본 동작
- DNS 서버의 기본 동작은 클라이언트에서 조회 메세지를 받고, 조회의 내용에 응답하는 형태로 정보를 회답 
- 조회 메세지에는 3가지 정보가 포함되어 있음
  - 이름 : 서버나 메일 배송 목적지와 같은 이름
  - 클래스 : 인터넷 이외에도 네트워크에서의 이용까지 검토하여 이것을 식별하기 위해 클래스라는 정보를 준비함  
  지금은 인터넷뿐이므로, 항상 IN 이라는 값을 사용
  - 타입 : 이름에 어떤 타입의 정보가 지원되는지 나타냄  
    이 타입에 따라서 클라이언트에 회답하는 정보의 내용이 달라짐
- 예를 들어, `www.naver.com` 이라는 서버의 IP 주소를 조사할 때, 클라이언트는 다음과 같은 정보를 포함한 조회 메세지를 DNS 서버에 보냄    
  - 이름, 클래스, 타입    
- DNS 서버는 이와 일치하는 것을 찾고, 일치하면 IP 주소를 클라이언트에 회답  
- IP 주소를 조회할때는 `A` 라는 타입을 사용하지만, 메일 배송 목적지를 조회할 때는 `MX`라는 타입 사용  
- 타입은 A, MX 뿐만 아니라 여러 타입이 있음  


#### 도메인의 계층
- 인터넷에는 막대한 수의 서버가 있으므로, 이를 전부 1대의 DNS 서버에 저장하는 것은 불가능  
  조회 메세지를 받은 DNS 서버에 정보가 등록되어 있지 않은 경우 DNS 동작 방식에 대해서 설명해봄
- 정보를 분산시켜 다수의 DNS 서버에 등록하고, 다수의 DNS 서버가 연대하여 어디에 정보가 등록되어 있는지 찾아내는 구조 
- DNS 서버에 등록한 정보에는 도메인명이라는 계층적 구조를 가진 이름이 붙여져 있음  
  `www.naver.com` 에서 점(dot, .) 으로 계층을 구분함  
   오른쪽에 위치한 것이 상위 계층을 나타냄. --> ex) com -> naver -> www 순
- 점으로 구분하는 것들이 하나의 도메인에 해당됨  
  `com` 이라는 도메인아래, `cyber`라는 도메인이 있고, `lab`이라는 도메인이 있게됨
- 이러한 도메인을 일괄적으로 DNS 서버에 등록함. 즉 도메인 한 대의 정보를 분할하여 복수의 DNS 서버에 등록하는 것은 불가능
- 한 대의 DNS 서버에 복수의 도메인의 정보를 등록할 수 있음
- `www.cyber.co.kr`
  - `kr`: 대한민국에 할당된 도메인
  - `co`: 국내이 도메인을 분류하기 위해 설치된 도메인
  - `cyber`: 회사에 할당된 도메인
  - `www` : 최하위의 서버


#### 담당 DNS 서버를 찾아 IP 주소를 가져온다
- 하위의 도메인을 담당하는 DNS 서버의 IP 주소를 상위의 DNS 서버에 차례대로 등록하는 방식을 사용
- ex) `lab.glasscom.com` 이라는 도메인을 담당하는 DNS 서버를 `glasscom.com`의 DNS 서버에 등록  
  `glasscom.com` 이라는 도메인을 담당하는 DNS 서버를 `com` 에 등록하는 방식
- 위의 설명에는 com 이나 kr 에서 끝나는 것처럼 보이지만, root domain 이라는 도메인이 있음
- root domain은 표기를 하지 않지만 존재함
- root domain의 서버를 인터넷에 존재하는 모든 DNS 서버에 등록하여 언제든지 root domain에 접속할 수 있도록 함
- root domain의 DNS 서버에 할당된 IP 주소는 전세계에 13개 밖에 되지 않고, 좀처럼 변경되지 않음
- 각 DNS 서버에 루트 도메인의 DNS 서버 정보를 저장하는 것은 어렵지 않으며,  
  이는 DNS 서버 소프트웨어와 함께 설정 파일로 배포되어 있음


#### DNS 서버 찾기 프로세스 
- `www.lab.glasscom.com` 이라는 도메인명 찾아가는 프로세스 확인해보기
- 가장 가까이에 있는 DNS 서버에 위의 도메인명을 조회하기로 가정해보자
  - 가장 가까운 DNS 서버에는 `www.lab.glasscom.com` 이라는 이름이 등록되어 있지 않아, 도메인의 계층을 위로부터 차례로 따라감
  - 가장 가까운 DNS 서버에는 루트 도메인의 DNS 서버가 등록되어 있으므로, 거기에 클라이언트로 받은 조회 메세지를 전송
  - 루트 도메인의 DNS 서버는 자체 등록되어 있는 `com` 도메인의 DNS 서버의 IP 주소를 반송
  - 가장 가까운 DNS 서버는 com 도메인의 DNS 서버에 조회 메세지를 보냄
  - 위의 process 를 반복
 

#### DNS 서버는 캐시 기능으로 빠르게 회답할 수 있음
- 현실의 인터넷에서는 한 대의 DNS 서버에 복수 도메인의 정보를 등록할 수 있음
- 상위와 하위의 도메인을 같은 DNS 서버에 등록하는 경우도 있음
- DNS 서버는 한 번 조사한 이름을 캐시에 기록할 수 있음. 이를 통해 이름이 존재하지 않은 DNS 서버에서도 회답할 수 있음
- 캐시의 원리에는 한 가지 주의할 점이 있는데, 캐시에 정보를 저장한 후 등록 정보가 변경되는 경우도 있으므로, 
  유효 기간을 설정하고 캐시에 저장된 데이터의 유효기간이 지나면 삭제함


### 프로토콜 스택에 메세지 송신을 의뢰한다
#### 메세지 송.수신 동작의 개요
- IP 주소를 조사했으면, IP 주소의 상대, 액세스 대상 웹 서버에 메세지를 송신하도록 OS의 내부에 있는 프로토콜 스택에 의뢰함
- 디지털 데이터를 송수신 하는 동작은 애플리케이션 전체에 공통임
- OS 내부의 프로토콜 스택에 메세지 송신 동작을 의뢰할 때는 Socket 라이브러리 프로그램 부품을 결정된 순번대로 호출함
- 데이터 송수신 동작 전체 개념
  - 데이터를 송 수신 하는 컴퓨터에 통로 같은 것이 있음. 이것을 통해 데이터가 흐르면서 상대측에 도착함  
  - 데이터는 어느 쪽에 쏟아부어도 상관없고, 양방향으로 데이터를 흘릴 수 있음
  - 송.수신 동작을 하기 전에 송.수신하는 양자 사이를 파이프로 연결하는 동작이 필요  
    요점은 파이프 양 끝에 있는 출입구인데, 이를 <b>소켓</b>이라고 부름
  - 실제로는 서버측에서 소켓을 만들고, 소켓에 클라이언트가 파이프를 연결하기를 기다림
- 데이터 송.수신 동작은 몇 단계로 나눠져 있는데 다음의 4단계로 요약할 수 있음
  - 소켓을 만듬(소켓 작성 단계)
  - 서버측의 소켓에 파이프를 연결(접속 단계)
  - 데이터를 송수신
  - 파이프를 분리하고 소켓을 말소
- 위의 4가지 동작을 실행하는 것은 OS의 프로토콜 스택
- 브라우저 등의 애플리케이션은 자체에서 파이프를 연결하거나, 거기에 데이터를 쏟아붓지 않고, 프로토콜 스택에 의해서 수행
- 지금 말하고자 하는 것은 OS의 의뢰 동작인데, 의뢰 동작은 Socket 라이브러리에 넣은 프로그램 부품을 호출하여 실행되지만,  
  송수신용 프로그램 부품은 프로토콜 스택에 전달하는 중개역을 수행할 뿐, 실질적인 작업은 하지 않음


#### 클라이언트와 서버의 메세지 송,수신 동작 모습
~~~c
메모리 영역 = gethostbyname("www.lab.cyber.co.kr")
디스크립터 = socket(<IPv4 사용>, <스트림형>...)
connect(디스크립터, 서버의 IP 주소와 포트 번호)
write(디스크립터, 송신 데이터, 송신 데이터 길이)
수신 데이터 길이 = read(<디스크립터>, <수신 버퍼>, .....)
close(<디스크립터>)
~~~

#### 소켓의 작성 단계
- Socket library 의 부품들을 호출을 순서대로 호출함
- 소켓 만듬 
  - `socket` library 만 호출하면 됨. 다음의 함수를 호출하면 socket 생성
- 소켓이 생기면 디스크립터라는 것이 돌아옴. 애플리케이션은 이를 받아 메모리에 기록해 둠  
  디스크립터는 소켓을 식별하기 위해 사용. 여러개의 소켓을 사용할 때(ex) 브라우저를 여러 개 여는 것과 같은 경우) 식별해야함

### 파이프를 연결하는 접속 단계
- 다음으로 만든 소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 의뢰함
- 디스크립터는 소켓을 만들 때 돌아온 디스크립터이며, 이를 통해 어느 소켓을 서버측의 소켓에 접속할지 판단하여 접속 동작을 실행
- IP 주소는 DNS 서버에 조회하여 조사한 액세스 대상 서버의 IP 주소
- IP 주소는 네트워크에 존재하는 각 컴퓨터를 식별하기 위해 각각에 서로 다른 값을 할당한 것임  
  즉 IP 주소로 지정할 수 있는 것은 네트워크의 어느 컴퓨터인가 하는 것이고, 접속 동작은 상대측 소켓에 대해 이루어지므로 소켓을 지정해야하는데, 이는 IP 주소로는 불가능함
- 따라서 <b>포트번호</b>를 통해 어느 소켓과 접속할지를 분명히 지정할 수 있음 
- 서버 측의 포트번호는 미리 약속된 값을 사용. 예를 들어 웹은 80, 메일은 25번과 같은 식     
  즉 미리 결정된 포트 번호를 지정하면, 번호에 대응하는 서버 어플리케이션의 소켓에 접속할 수 있음
- 서버에서도 클라이언트측의 소켓의 번호가 필요할텐데 이부분은 어떻게 되어있는 것일까?   
  - 클라이언트측 소켓의 포트 번호는 소켓을 만들 때 프로토콜 스택이 적당한 값을 골라서 할당됨
  - 그리고 이 값을 프로토콜 스택이 접속 동작을 실행할 때, 서버측에 통지함

### 메세지를 주고받은 송.수신 단계
- 애플리케이션은 소켓을 직접 다룰 수 있으므로, Socket 라이브러리를 통해 프로토콜 스택에 그 일을 의뢰함  
  `write` 를 통해 구체적으로 다음과 같은 일을 함
  - 애플리케이션은 송신 데이터를 메모리에 준비  
    여기서 송신 데이터는 HTTP의 request message를 말함
  - `write` 호출 시, 디스크립터와 송신 데이터를 지정함
  - 프로토콜 스택이 송신 데이터를 서버에게 전송
  - 소켓에는 연결 상대가 기록되어 있으므로, 디스크립터로 소켓을 지정하면 연결된 상대가 판명되어 전부 액세스 대상의 서버에 도착
  - 서버는 수신 동작을 실행하여 받은 데이터의 내용을 조사하고 적절한 처리를 실행하여 응답 메세지 반송
- `read` 를 통해 메세지 송신. 
- 이때 수신한 응답 메세지를 저장하기 위한 메모리 영역을 지정하는데, 이 메세지 영역을 수신 버퍼라고 함
- 응답 메세지가 돌아올 때, read가 받아서 수신 버퍼에 저장

### 연결 끊기 단계에서 송.수신이 종료됨
- `close` 를 호출하여 연결 끊기 단계로 들어가도록 의뢰
- 소켓 사이를 연결한 파이프와 같은 것이 분리되고 소켓도 말소됨
- 웹에서 사용하는 HTTP 프로토콜에서는 응답 메세지의 송신을 완료했을 때 웹 서버측에서 연결 끊기 동작을 실행하므로,  
  먼저 웹서버 측에서 close 를 호출하여 연결을 끊음
- 이것이 클라이언트 측에 전달되어 클라이언트의 소켓은 연결 끊기 단계로 들어감
- 그리고 브라우저가 read로 수신 동작을 의뢰했을 때 read는 수신한 데이터를 건네주는 대신 송.수신 동작이 완료되어 연결이 끊겼다는 사실을 브라우저에게 통지함