## chapter07 - 웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다
### 개요
- 앞서 웹 서버 바로 앞에 있는 방화벽, 캐시 서버, 부하 분산 장치라는 장치를 탐험함
- 이번 장에서는 웹 서버 안으로 들어감
- '1. 서버의 개요
  - 서버 애플리케이션 구조, 기동 후에 수행하는 준비 동작 등을 설명
- '2. 서버의 수신 동작
  - 서버의 프로토콜 스택의 수신 동작을 탐험
  - 신호를 수신하고 이것을 디지털 데이터의 패킷으로 되돌려주며, 여기에서 HTTP의 메세지를 추출하는 동작
  - 프로토콜 스택이 수신한 메세지를 Socket 라이브러리를 통해 웹 서버 어플리케이션에 건네주는 곳도 탐험
- '3. 웹 서버 소프트웨어가 리퀘스트 메세지의 의미를 해석하여 요구에 응함
- '4. 웹 브라우저가 응답 메세지를 받아 화면에 뿌림   

### 서버의 개요
#### 클라이언트와 서버의 차이점
- 서버는 서버를 기동한 후 여러 가지 준비 동작을 하기 시작하여 클라이언트에서의 액세스에 응하는 상태가 됨
- 서버 머신은 용도에 따라 다양한 종류가 있으며, 하드웨어나 OS 부분은 클라이언트와 다른 것도 있음
- 네트워크에 관한 부분(프로토콜 스택, LAN 어댑터, Socket 라이브러리) 등의 기능은 클라이언트와 동일
- 가지고 있는 기능은 같지만, 사용하는 방법까지 같은 것은 아님
- <b>클라이언트는 접속 동작을 수행하고, 서버는 기다리는 형태가 되므로, 소켓 라이브러리 사용법이 조금 달라짐</b>
- 서버의 애플리케이션은 동시에 다수의 클라이언트 PC와 대화한다는 차이점이 있음

#### 서버 애플리케이션의 구조
![img](https://github.com/koni114/TIL/blob/master/Network/books/one_percent_network/img/network_25.png)

- 클라이언트가 접속할 때마다 새로 서버 프로그램을 작동하여 서버 애플리케이션이 클라이언트와 1:1로 대화하는 방법을 선택하는 것이 일반적
- 서버 구조 관점에서의 클라이언트 대화 순서
  - '1. 서버 프로그램을 접속을 기다리는 부분과 클라이언트와 대화하는 부분으로 나눔
  - '2. 설정 파일 읽기 등의 초기화 동작을 마쳤을 때 접속을 기다리는 부분을 실행
  - '3. 소켓을 작성하고 소켓을 클라이언트에서의 접속 동작을 기다리고 쉬는 상태가 됨
  - '4. 클라이언트 접속시, 다시 작동하여 접속을 기다림
  - '5. 클라이언트와 대화하는 부분을 작동. 접속이 끝난 소켓을 건네줌
  - '6. 클라이언트와 대화하는 부분은 접속이 끝난 소켓을 사용하여 대화 시작
  - '7. 다시 반납
- 클라이언트와 대화하는 부분(b)가 클라이언트와 1:1로 대응
- <b>서버 OS는 멀티테스크, 멀티스레드</b>를 통해 다수의 프로그램을 함께 작동
- 위의 방법을 사용하면, 새로운 클라이언트 등장할 때마다 매번 기동시 시간이 걸리는 단점이 있어, 미리 클라이언트와 대화하는 부분을 몇개 작동시켜 놓고, 클라이언트가 접속했을 때 클라이언트의 상대를 처리하지 않는 비어있는 것을 찾아 접속

#### 서버측의 소켓과 포트 번호
- 서버 애플리케이션이 Socket 라이브러리를 호출하는 부분의 개요를 정리
- 송.수신 구조에서 클라이언트와 서버라는 식으로 역할을 결정하지 말고 좌우 대칭으로 어디에서나 자유롭게 데이터를 송신할 수 있도록 해 두는 방법이 좋음
- 접속동작은 좌우 대칭으로 만들 수 없음.  
  한쪽은 기다리고, 한쪽에서 접근하여 접속해야함. 즉 접속하는 측이 클라이언트, 접속을 기다리는 측이 서버가 됨
- 클라이언트 데이터 송.수신 동작
  - '1. 소켓을 만듬(소켓 작성 단계)
  - '2. 서버측의 소켓과 파이프로 연결함(접속 단계) 
  - '3. 데이터를 송.수신(송.수신 단계)
  - '4. 파이프를 분리하고 소켓을 말소함(연결 끊기 단계) 
- 서버 데이터 송수신 동작
  - '1. 소켓을 만듬(소켓 작성 단계)
  - '2-1. 소켓을 접속 대기 상태로 만듬(접속 대기 상태)
  - '2-2. 접속을 접수 함(접속 접수 단계)
  - '3. 데이터를 송.수신(송.수신 단계)
  - '4. 파이프를 분리하고 소켓을 말소함(연결 끊기 단계) 

#### 서버 애플리케이션의 송신 동작
~~~t
# (a). 접속을 기다리는 부분
동작 개시;
<디스크립터1> = socket(<IPv4를 사용>, <TCP를 사용함>, ...) # (1) 소켓 작성
bind(<디스크립터1>, <포트 번호 등>, ...);                 # (2-1) 접속 대기상태 만듬
listen(<디스크립터1>, ...);                            # (2-1) 접속 대기상태 만듬
<디스크립터2> = accept(<디스크립터1>, ...)                # (2-2) 접속 접수

클라이언트와 대화하는 부분을 호출(<디스크립터2>);
accpet로 돌아감;
~~~
- (1) 먼저 `socket` 을 호출하여 소켓을 만듬 
- (2-1) `bind`를 호출하여 소켓에 포트 번호를 기록  
  클라이언트측에서 접속 동작을 실행할 때 서버측의 소켓에 할당한 포트 번호를 지정하는데, 이것이 포트 번호임(ex) web, 80번)
- (2-1) `listen`을 호출하여 소켓에 접속하기를 기다리는 상태라는 제어 정보를 기록함  
  이렇게 되면 클라이언트의 접속 동작의 패킷이 도착하는 것을 기다리는 상태가 됨
- (3). `accept`를 호출하여 접속을 접수. 접속을 접수하는 부분은 서버 애플리케이션을 기동한 후 즉시 실행  
- 접속 패킷이 도착하지 않았으면, 도착을 기다리는 상태가 되어 패킷이 도착할 때 접속 접수 동작을 실행
- 그래서 보통 `accept` 실행 시점에서 보통 서버측은 패킷의 도착을 기다리는 상태가 되며, 애플리케이션은 쉬는 상태가 됨
- 기억해야 할 특징 중에 하나는 <b>새 소켓을 클라이언트 측의 소켓과 접속한 후 원래 소켓은 그대로 접속 대기 상태인 채로 둠. 즉 잇달아 복사하여 새 소켓을 만드는 부분이 요점</b>
- 새 소켓을 만들지 않고 접속 대기의 소켓에 그대로 접속하면 접속 대기의 소켓이 없어져 다음의 다른 클라이언트가 접속하면 곤란해짐
- 새로 만든 소켓에도 접속 대기 소켓과 같은 포트 번호를 할당해야 함
- 소켓을 지정할 때 서버측의 소켓에 할당한 포트 번호 뿐만 아니라, 클라이언트 측의 포트 번호도 사용하고, IP 주소도 추가하여 다음의 네 가지 정보를 사용하는 것
  - 클라이언트 측의 IP 주소
  - 클라이언트 측의 포트 번호
  - 서버측의 IP 주소
  - 서버측의 포트 번호 
- 서버 측의 소켓에는 같은 번호를 가진 여러 개의 소켓이 존재하고, 클라이언트측의 소켓은 모두 다른 포트 번호를 할당하므로  
  클라이언트 측의 포트 번호에 따라 소켓을 지정할 수 있음
- <b>다른 포트를 사용한다는 규칙은 한 대의 클라이언트 내부에서 적용되므로 클라이언트가 복수인 경우에는 각 클라이언트에서 같은 포트 번호를 사용할 수도 있음</b>
- ex) IP 주소가 198.18.203.154인 클라이언트가 198.18.142.86 클라이언트와 포트 번호가 1025로 같을 수 있음
- 위의 4개 정보를 통해 소켓을 구분할 수 있지만, 디스크립터를 사용하는 이유는 '1. 소켓을 만든 직후 아직 접속하지 않은 상태일 때는 네 가지 정보가 준비되어 있지 않음. '2. 디스크립터라는 한 개의 정보를 나타내는 쪽이 더 간단함

### 서버의 수신 동작
#### LAN 어댑터에서 수신 신호를 디지털 데이터로 변환한다
- 서버에 도착하는 패킷의 실체는 전기나 빛의 신호임
- 수신 동작의 전체 모습 요약
  - '1. LAN 어댑터에서 수신하고 디지털 데이터로 바꿈(클록의 위치에서 신호의 변화의 방향 조사)
  - '2. FCS(Frame Check Sequence)에서 오류 검사용 데이터를 이용하여 오류 유무 검사
  - '3. MAC 헤더에 있는 수신처 주소 조사하여 자신을 수신처로 해서 보낸 것인지 확인 후 버퍼 메모리 저장 
  - '4. 인터럽트라는 방법을 사용하여 LAN 어댑터에서 CPU로 패킷의 도착을 알림
  - '5. LAN 어댑터의 버퍼 메모리에서 수신한 패킷을 추출

#### IP 답당 부분의 수신 동작
- 프로토콜 스택의 IP 담당 부분은 IP 헤더를 점검
- 자신을 대상으로 한 것인지 판단 
- 조각 나누기에 의한 패킷의 분할이 있는지 조사
- TCP 담당 부분 또는 UDP 담당 부분에 패킷을 건네줌

#### TCP 담당 부분이 접속 패킷을 수신했을 때의 동작





## 용어 정리
- CGI(Common Gateway Interface)
  - 서버와 애플리케이션 간에 데이터를 주고 받는 방식 또는 convention.
  - 