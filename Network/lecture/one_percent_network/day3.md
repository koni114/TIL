## day - 3 - chapter02
### 탐험 여행의 경유지
- 이 장에서는 OS에 내장된 프로토콜 스택이 어떻게 송신을 의뢰하는지에 대해 설명
- 애플리케이션에서 의뢰를 받은 프로토콜 스택이 TCP 프로토콜을 이용해서 메세지를 송신하는 동작은 4단계로 요약 가능
  - 소켓을 작성
  - 서버에 접속. 클라이언트 측의 소켓을 서버측의 소켓에 접속하는 단계
  - 데이터를 송.수신  
    데이터를 작은 조각으로 분해하여, 서버를 향해 송신.  
    오류 때문에 패킷이 없어진다고 가상하여 분할한 조각이 제대로 서버측에 도착했는지 확인
  - 서버에서 소켓을 끊어 소켓을 말소  
    송,수신이 끝나면, 서버에서 소켓을 끊고 소켓을 말소시킴  
    연결 끊기 동작의 역할은 메세지 송.수신이 끝난 것을 클라이언트와 서버가 함께 확인
  - IP와 이더넷의 패킷 송.수신 동작  
    TCP 프로토콜의 메세지 송.수신 동작의 다음은 실제로 패킷을 송.수신하는 동작
  - UDP 프로토콜을 이용한 송.수신 동작  
    TCP 프로토콜이 특정한 경우 문제가 될 수 있기 때문에 UDP 프로토콜이 준비되어 있음

### 소켓을 작성한다
#### 프로토콜 스택의 내부 구성

![img](https://github.com/koni114/TIL/blob/master/Network/lecture/one_percent_network/img/network_06.png)

- 애플리케이션 
  - 맨 위에 있는 것은 <b>네트워크 애플리케이션</b>이며, 브라우저, 메일러, 웹 서버, 메일 서버 등의 프로그램이 여기에 해당
  - 어떤 애플리케이션도 네트워크에서 데이터를 송,수신 하는 동작은 비슷함
  - 애플리케이션 아랫부분에는 Socket 라이브러리가 있으며, 그 안에는 리졸버가 내장되어 있음
- OS(프로토콜 스택)
  - 프로토콜 스택의 윗부분에는 TCP, UDP 프로토콜이 존재
  - 브라우저나 메일 등의 일반적인 애플리케이션이 데이터를 송.수신할 경우에는 TCP
  - DNS 서버에 대한 조회 등에서 짧은 제어용 데이터를 송.수신할 경우에는 UDP
  - 그 아래에는 IP 프로토콜을 사용하여 패킷 송.수신 동작을 제어하는 부분이 있음
  - 데이터를 운반할 때는 데이터를 작게 나누어 패킷이라는 형태로 운반하는데, 이 패킷을 통신 상대까지 전달하는 것이 IP의 주 역할
  - IP 안에는 ICMP, ARP 라는 프로토콜을 다루는 부분이 포함되어 있음
  - ICMP : 패킷을 운반할 때 발생하는 오류를 통지
  - ARP : IP 주소에 대응하는 이더넷의 MAC 주소 조사
- 드라이버 소프트웨어
  - IP 아래에 있는 LAN 드라이버는 LAN 어댑터의 하드웨어를 제어

#### 소켓의 실체는 통신 제어용 제어 정보
- 프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있으며, 여기에 통신 동작을 제어하기 위한 제어 정보를 기록  
ex) 통신 상대의 IP주소는 무엇인가, 포트 번호는 무엇인가, 통신 동작이 어떤 진행 상태에 있는가 등
- <b>소켓은 개념적인 것이므로, 실체가 없으므로 제어 정보가 소켓의 실체, 또는 제어 정보를 기록한 메모리 영역이 소켓의 실체라고 할 수 있음</b>
- 프로토콜 스택은 이 제어정보를 참조하면서 동작함  
  ex) 데이터를 송신할 때는 소켓에 기록되어 있는 상대측의 IP 주소나 포트 번호를 보고 그 IP 주소와 포트번호를 대상으로 데이터를 송신  
  도중에 데이터가 없어질 경우를 고려하여, 소켓에 응답이 돌아오는지의 여부와 경과 시간등이 기록되어 있음 

#### 소켓의 내용 직접 확인하기
- `netstat` 명령어를 통해 실제 소켓의 내용을 화면으로 확인 가능

![img](https://github.com/koni114/TIL/blob/master/Network/lecture/one_percent_network/img/network_07.png)

- `Proto`: 프로토콜의 종류. TCP/IP 프로토콜을 사용하여 데이터를 송.수신할 경우에는 TCP와 UDP 중 하나
- `Local Address` : netstat 명령을 실행한 기계 자체 예(로컬측)의 IP 주소와 port 번호  
  이 예는 여러개의 LAN 어댑터를 장착하고 있는 기계에서 실행한 것  
  여러 개의 IP 주소가 표시되어 있음
- `Foreign Address` : 통신 상대측(원격측)의 IP 주소와 포트 번호
- `(state)`: 통신 상태를 나타냄. 
  - `LISTENED` : 상대의 접속을 기다리고 있는 상태
  - `ESTABLISHED` : 접속 동작이 끝나고 데이터가 통신중인지를 나타냄 
- 한 행이 하나의 소켓에 해당
- 소켓을 만든다는 동작은 여기에 새로 한 행의 제어정보를 추가하고 '여기부터 통신을 시작하는 곳' 이라는 식으로 상태를 기록하거나, 송 수신 데이터를 일시적으로 저장하는 버퍼 메모리를 준비하는 등 통신을 준비하는 작업

#### Socket을 호출했을 때의 동작
- 브라우저가 socket이나 connect라는 Socket 라이브러리의 프로그램 부품을 호출했을 때 프로토콜 스택의 내부가 어떻게 움직이는지 살펴보자

![img](https://github.com/koni114/TIL/blob/master/Network/lecture/one_percent_network/img/network_08.png)

- 준비
  - 소켓을 만드는 단계
  - socket을 호출하여 소켓을 만들 것을 의뢰하면, 프로토콜 스택은 의뢰에 따라 한 개의 소켓을 만듬
  - 프로토콜 스택이 최초로 하는 일은 소켓 한 개 분량의 메모리 영역을 확보하는 것
  - 메모리 영역에는 소켓은 작성된 직후여서 아직 송.수신 동작이 시작되지 않은 초기 상태임을 나타내는 제어 정보가 저장되어 있음
  - 소켓이 만들어지면 소켓을 나타내는 <b>디스크립터</b> 를 애플리케이션에 알려줌
  - 디스크립터에는 누구와 누가 통신하고 있는지, 그리고 그것이 어떤 상태로 있는지 등의 정보가 전부 기록되어 있음
  - 이렇게 하면 통신 상대의 정보를 일일이 애플리케이션에게 전달받을 필요가 없음


### 서버에 접속한다
#### 접속의 의미
- 소켓을 만들면 애플리케이션(브라우저)은 connect를 호출  
  그러면 프로토콜 스택은 자기쪽의 소켓을 서버측 소켓에 접속함
- 하지만, 이더넷이나 통신 회선 등의 케이블은 항상 접속된 상태에 있으므로, 케이블을 연결하거나 분리하지 않음
- 접속의 의미 첫 번째는 서버의 IP주소나 포트 번호를 프로토콜 스택에 알리는 동작이 필요한데, 이것이 접속 동작의 한 가지 역할
- 두 번째는 클라이언트측에서 서버측에 통신 동작의 개시를 전달하는 것도 접속 동작의 역할 중 하나
- 데이터 송수신 동작을 실행할 때는 송.수신하는 데이터를 일시적으로 저장하는 메모리 영역이 필요한데, 이 메모리 영역을 '버퍼 메모리'라고 부름    
이러한 버퍼 메모리 확보도 접속 동작을 할 때 실행됨  


#### 멘 앞부분에 제어 정보를 기록한 헤더를 배치한다
- 제어 정보에는 크게 두 종류가 있음  
  하나는 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보  
  접속 동작의 단계에서는 패킷의 내용은 오직 제어 정보로만 이루어져 있음. 이 제어 정보를 패킷의 맨 앞부분에 배치하는 곳부터 헤더라고 함
- 이더넷과 IP에도 같은 제어 정보가 있고, 헤더가 존재하므로, 각각 이더넷 헤더, IP 헤더 등으로 불러 구분
- 제어 정보는 소켓에 기록하여 프로토콜 스택의 동작을 제어하기 위한 정보가 더 있음  
  ex) 애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보 등이 수시로 기록됨
- 소켓의 제어 정보는 프로토콜 스택의 프로그램과 일체화되어 있다고 해도 좋음
- 소켓의 제어 정보는 상대방이 볼 수 없으며, 대신 헤더의 규칙 정보를 통해 서로(클라이언트-서버)가 연락을 취하기 때문 
- <b>통신 동작에 이용하는 제어 정보는 다음의 두 종류</b>
  - 헤더에 기입되는 정보
  - 소켓(프로토콜 스택의 메모리 영역)에 기록되는 정보 


#### 접속 동작의 실체
- 다음의 process는 접속 동작 `connect(<디스크립터>, <서버측의 IP 주소와 포트 번호>)` 의 순서를 설명
- 서버측의 IP 주소와 포트 번호를 쓰면 명령이 프로토콜 스택의 TCP 담당 부분에 전달됨
- 그러면 TCP 담당 부분은 IP 주소로 표시된 상대, 즉 서버의 TCP 담당 부분과의 사이에 제어를 주고 받음
- 첫 번째로 데이터의 송.수신 동작의 개시를 나타내는 제어 정보를 기록한 헤더를 만듬  
  헤더에는 다수의 항목이 있는데, 가장 중요한 것은 <b>송신처, 수신처의 포트 번호임</b>
- 이를 통해 송신처가 되는 클라이언트측의 소켓과 수신처가 되는 서버측의 소켓을 지정할 수 있음
- 접속해야 하는 소켓을 확실히 하고 <b>컨트롤비트인 SYN</b> 이라는 비트를 1로 만듬  
  이렇게 해서 접속함
- TCP 헤더 제작 후, IP 담당 부분에 건네주어 송신하도록 의뢰 
- IP 담당 부분이 패킷 송신 동작을 실행하고 네트워크를 통해 패킷이 서버에 도착하면 서버측의 IP 담당 부분이 이것을 받아 TCP 담당 부분에 건네줌
- TCP 담당 부분은 TCP 헤더를 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 찾아냄
- 소켓에 필요한 정보를 기록하고, 접속 동작이 진행중이라는 상태가 됨
- 서버의 TCP 담당 부분은 응답을 돌려보냄. 이 때 클라이언트와 마찬가지로 송신처와 수신처의 포트 번호나 SYN 비트 등을 설정한 TCP 헤더를 만듬
- 응답을 돌려보낼 때 ACK라는 컨트롤 비트도 1로 만듬. 이는 패킷을 받은 것을 알리기 위한 동작
- TCP 헤더를 IP 담당 부분에 건네주어 클라이언트에 반송하도록 의뢰
- 패킷이 클라이언트에 돌아오고, IP 담당 부분을 경유하여 TCP 담당 부분에 도착함
- TCP 헤더를 조사하여 서버측의 접속 동작이 성공이였는지를 SYN = 1 여부를 통해 확인
- 마지막으로 패킷이 클라이언트에 잘 도착함을 알리기 위해 ACK 를 1로 만든 TCP 헤더를 서버측에 반송
- 이것이 서버에 도착하면 데이터를 송수신할 수 있는 상태가 됨 
- 접속 동작 순서 간단 요약
  - 데이터 송수신을 위한 헤더 제작
  - TCP 헤더 제작 후, IP 담당 부분에 건네주어 송신하도록 의뢰 
  - IP 담당 부분이 패킷 송신 동작 실행하고, 네트워크를 통해 패킷이 서버에 도착하면 서버측의 IP 담당 부분이 이것을 받아 TCP 담당 부분에게 전달
  - TCP 담당 부분은 TCP 헤더를 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 찾아냄
  - 소켓에 필요한 정보를 기록하고, 접속 동작이 진행중이라는 상태가 됨
  - 서버의 TCP 담당 부분은 ACK = 1 로 하여 응답을 돌려보냄
  - 패킷이 클라이언트에 도착한 후, 헤더를 조사하여 서버에 정상 연결하였는지 (SYN = 1) 확인
  - 패킷이 클라이언트에 잘 도착했는지 여부를 다시 서버에 ACK = 1 로 하여 반송


### 데이터를 송.수신 한다
#### 프로토콜 스택에 HTTP 리퀘스트 메세지를 넘긴다
- 애플리케이션이 `write`를 호출하여 송신 데이터를 프로토콜 스택에 건네주는 곳부터 시작하고,  
  이것을 받은 프로토콜 스택이 송신 동작을 실행하는 순서로 진행
- 프로토콜 스택은 받은 데이터의 내용에 무엇이 쓰여있는지 알 수 없음  
  write 를 호출할 때, 송신 데이터의 길이를 지정하지만 구체적인 내용은 알지 못함  
- 프로토콜 스택은 곧바로 송신하는 것이 아니라, 일단 자체의 내부에 있는 <b>송신용 버퍼 메모리</b>에 저장함 
- 그 이유는 어느 경우든지 한 번의 송신 의뢰에서 건네주는 데이터의 길이는 애플리케이션의 사정에 따라 결정되며 프로토콜 스택이 이를 결정할 수 없기 때문
- 이렇게 되면 작은 패킷을 많이 보낼수도 있으므로, 네트워크가 비효율적이므로 어느 정도 데이터를 저장하고 나서 송.수신 동작을 함
- 판단 요소는 OS마다 조금씩 다르지만 다음과 같은 요소로 판단함
  - 한 패킷에 저장할 수 있는 데이터의 크기  
    프로토콜 스택은 MTU라는 매개변수를 바탕으로 판단. MTU는 한 패킷으로 운반할 수 있는 디지털 데이터 최대 길이 
  - 타이밍  
    애플리케이션의 송신 속도가 느려지는 경우, MSS에 가깝게 데이터를 저장하면 여기에 시간이 걸려 송신 동작이 지연되므로 적당한 곳에서 송신 동작을 실행해야 함  
    프로토콜 스택은 내부 타이머가 있어 일정 시간 경과하면 패킷을 송신
- 위의 2가지 판단 요소는 trade-off 관계를 가짐  
  실제로 두가지를 어떻게 판단할지는 프로토콜 스택을 개발하는 개발자에게 맡겨져 있음
- 프로토콜 스택에만 맡긴다면 좋지 않은 일이 생길 수도 있으므로, 애플리케이션측에서 송신의 타이밍을 제어하는 여지도 남겨둠  
예를 들어, 버퍼에 머물지 말고 바로 송신하라고 보내면 프로토콜 스택은 버퍼에 머물지 않고 송신 동작 실행  

![img](https://github.com/koni114/TIL/blob/master/Network/lecture/one_percent_network/img/network_09.png)

- MTU : 패킷 한 개로 운반할 수 있는 디지털 데이터의 최대 길이. 이더넷에서는 보통 1,500바이트
- MSS : 헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP의 데이터의 최대 길이


#### 데이터가 클 때는 분할하여 보낸다
- 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS 크기에 맞게 분할하고, 분할된 조각을 한 개씩 패킷에 넣어 송신
- 맨 앞부분에 TCP 헤더를 부가함


#### ACK 번호를 사용하여 패킷이 도착했는지 확인한다
- 패킷을 송신한 이후에는 확인 동작으로 넘어감
- TCP 담당 부분은 데이터를 조각으로 분할할 때, 통신 개시부터 따져서 몇 번째 바이트에 해당되는지 세어둠
- 데이터의 조각을 송신할 때 세어둔 값을 TCP 헤더에 기록하는데, 시퀀스 번호라는 항목이 해당됨
- 패킷 전체에서 헤더 길이를 빼면 데이터의 크기를 계산할 수 있으므로, 수신측에서 이 방법에 따라 크기를 산출
- 수신측에서 패킷의 누락여부를 시퀀스 번호를 통해서 파악 가능
  예를 들어, 1461인 패킷이 도착하지 않았는데, 2921 시퀀스 번호인 패킷이 도착하였다면 누락되었음을 확인
- 누락되지 않음을 확인했다면, 수신한 데이터와 합쳐 몇 번째 바이트까지 수신한 것인지 계산하고 그 값을 TCP 헤더의 ACK 번호에 기록
- 시퀀스 번호는 초기값을 난수로 생성. 이는 보안 때문  
  실제로는 SYN 에 1 값을 설정할 때 시퀀스 번호의 초기값 설정
- 데이터의 흐름은 양방향(클라이언트 - 서버)이므로, 이러한 경우를 대응하기 위해 좌우를 역전시켜 송수신함.  
- 클라이언트 -> 서버
  - 클라이언트에서 시퀀스 생성
  - 데이터와 함께 서버에 통지
  - 서버측에서 ACK 번호를 산출하여 클라이언트에 반송 
- 서버 -> 클라이언트는 동일하되 위의 클라이언트 -> 서버 데이터 패킷 송수신 프로세스와 반대
- 실제 데이터 송수신 프로세스
  - 클라이언트 -> 서버로 보내는 데이터에 관한 시퀀스 번호 초기값을 서버에 통지
  - 서버에서 초기값으로부터 ACK 번호를 산출하여 클라이언트에 반송  
    반송하는 데이터에 서버의 시퀀스 번호 초기값도 함께 반송
  - 시퀀스번호와 ACK 번호가 준비되었으므로, 데이터 송 수신 수행
- TCP는 이러한 방법으로 데이터를 받은 것을 확인하는데, 확인할 때까지 송신한 패킷을 메모리 버퍼에 저장하고, 만약 ACK 번호가 상대방으로부터 돌아오지 않으면 재전송
- 이 구조는 오류가 발생해도 언제든지 재전송하여 회복처리가 가능  
  이 때문에 LAN 어댑터, 버퍼, 라우터 모두 회복 조치를 취하지 않음
- 만약 도중에 케이블이 분리되거나 서버가 다운되어 TCP가 아무리 다시 보내도 데이터가 도착하지 않은 경우가 있는데   
  이때 몇 번 다시 보낸 후 회복의 전망이 없는 것으로 보고 데이터 송신 동작을 강제로 종료


#### 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다
- ACK 번호가 돌아오는 것을 기다리는 시간을 timeout 값이라고 함
- 대기 시간이 너무 짧게되면 ACK 번호가 돌아오기 전 다시 보내 네트워크 혼잡을 악화시키며,  
  대기 시간이 너무 길게되면 패킷을 다시 보내는 동작이 지연되어 속도 저하의 원인이 됨
- 따라서 적절한 대기 시간을 설정하는 것이 중요한데, 이는 서버가 가까운지 먼지에 따라서 다르므로,  
  TCP는 대기 시간을 동적으로 변경하는 방법을 사용
- ACK 번호가 돌아오는 시간을 기준으로 대기 시간을 판단하는 것임


#### 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다
- 윈도우 제어는 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고  차례대로 연속으로 복수의 패킷을 보내는 방법
- 이렇게 해서 ACK 번호를 기다리는 시간의 낭비가 없어짐
- 하지만 이렇게되면 수신측의 능력을 초과하여 패킷을 보내는 사태가 일어날 수도 있음
- 수신측의 능력을 초과한다는 것은 수신측은 버퍼 메모리에 데이터를 일시 보관하는데, 애플리케이션에게 데이터를 건네주는 속도보다  
  수신받는 데이터의 속도가 더 빠르게 되면 버퍼 메모리의 크기보다 수신 데이터의 크기가 커져 패킷이 도착해도 오류가 발생한 것처럼 보이는 것을 말함
- 이는 수신측에서 송신측에 수신 가능한 데이터 양을 통지하고, 수신측은 이 양을 초과하지 않도록 송신 동작을 실행하는데, 이것이 윈도우 제어 방식의 개념
- 이러한 정보를 TCP 헤더의 윈도우 필드에 저장하여 제공
- 수신 가능한 데이터의 양의 최대값을 <b>윈도우 사이즈</b>라고 함

#### ACK 번호와 윈도우를 합승한다
- 송.수신 동작의 효율성을 높이기 위해 ACK 번호와 윈도우를 통지하는 타이밍을 고려해야 함
- 윈도우 통지가 필요한 것은 수신측이 수신 버퍼에서 데이터를 추출하여 애플리케이션에 건네주었을 때임   
  이러한 작업은 애플리케이션에서 의뢰가 있을 때 일어나기 때문에 송신측에서는 알수가 없음. 
- ACK 번호는 수신측에서 데이터를 받았을 때 내용을 조사하여 정상 수신을 확인할 수 있는 경우에만 송신측에 보냄
- 본래의 개념 그대로 실현하면 윈도우 통지와 ACK 번호 통지의 패킷이 따로따로 송신측에 보내져 효율성이 저하됨
- 수신측은 ACK 번호나 윈도우를 통지할 떄 소켓을 바로 보내지 않고 잠시 기다림
- 기다리다가 다음 통지 동작이 일어나면 양쪽을 상승시켜 한 개의 패킷으로 묶어 보냄
- ACK 번호는 데이터를 어디까지 받았는지, 즉 수신한 데이터의 끝이 어디인지를 송신측에 알리는 것이므로, 연속으로 ACK 번호 통지가 일어나면 최후의 것만 통지함
- 윈도우 통지가 여러번 일어나는 것도 애플리케이션 데이터를 건네주는 동작이 연속으로 일어나는 것이므로 최후의 것만 통지하면 됨

#### HTTP 응답 메세지를 수신한다
- HTTP 리퀘스트 메세지를 보내면 다음에는 웹 서버에서 응답 메세지가 돌아오기를 기다리고, 응답 메세지가 돌아오면 그것을 수신
- 브라우저는 리퀘스트 메세지를 송신해 달라고 의뢰
- 서버에서 돌아오는 응답 메세지를 받기 위해 read 프로그램 호출
- read를 경유하여 프로토콜 스택에 제어가 넘어가고 프로토콜 스택이 움직이기 시작함 
- 프로토콜 스택은 수신 버퍼에서 수신 데이터를 추출하여 애플리케이션에 건네줌
- 리퀘스트 메세지의 송신을 완료하고 난 후의 얼마 안된 시점에서는 응답 메세지가 돌아오지 않았을텐데,  이 때는 수신 버퍼에 데이터가 들어가지 않음
- 수신 버퍼에서 추출하여 애플리케이션에 건네주는 작업을 잠시 보류함(다른 작업을 하고 있음)
- 응답 메세지의 패킷이 도착했을 때 그것을 수신하여 애플리케이션에 건네주는 작업을 재개함

### 서버에서 연결을 끊어 소켓을 말소한다
#### 데이터 보내기를 완료했을 때 연결을 끊는다
- 데이터 송수신을 종료하는 것은 애플리케이션이 송신해야하는 데이터를 전부 송신 완료라고 판단했을 때임
- 송신을 완료한 측이 연결 끊기 단계로 들어가게 되는데, 어디에서 데이터 송.수신 동작이 끝나는지는 애플리케이션에 따라 다름
- 프로토콜 스택은 어느 쪽에서 먼저 연결 끊기 단계에 들어가도 좋게 만들어져 있음
- 다음은 서버측에서 먼저 연결 끊기 단계에 들어간다고 간주하고 설명

##### 서버측에서 연결 끊기 단계 시작 프로세스
- 서버 측
  - 서버측의 애플리케이션이 먼저 Socket 라이브러리의 close를 호출
  - 서버측의 프로토콜 스택이  FIN 이라는 컨트롤 비트를 1로 만들어 추가한 TCP 헤더를 만들고, 클라이언트에 송신  
    이와 동시에 서버측의 소켓에 연결 끊기 동작에 들어갔다고 정보를 기록
- 클라이언트 측
  - FIN에 1을 설정한 TCP 헤더가 도착하면 클아이언트측의 프로토콜 스택은 자신의 소켓에 서버측이 연결 끊기 동작에 들어갔다는 것을 기록   
  ACK 번호를 서버측에 반송하고  이것이 끝나면 애플리케이션이 데이터를 가지러 올 때까지 기다림 
  - 애플리케이션이 read를 호출하여 데이터를 가지러 오는데, 바로 데이터를 건네지 않고 서버에서 보낸 데이터를 전부 수신 완료했다는 사실을 클라이언트측의 애플리케이션에 알림
  - 서버에서 보낸 데이터를 전부 수신 완료하면 클라이언트도 종료
  - 클라이언트 측의 애플리케이션도 close를 호출하여 데이터 송 수신 동작을 끝냄
  - 클라이언트 측의 프로토콜 스택은 서버측과 마찬가지로 FIN = 1 설정한 TCP 헤더를 만들고 IP 담당 부분에 의뢰하여 서버 송신
  - 서버에서 ACK 번호가 돌아오면 서버와의 대화가 끝남

#### 소켓을 말소한다
- 서버와의 대화가 끝나면 소켓을 사용하여 서버와 대화할 수 없게됨
- 중요한 것은 <b>소켓을 말소하지 않고 잠시 기다린 후 소켓을 말소함</b>

#### 데이터 송수신 동작 정리
- 소켓을 작성  
  - 보통 서버측에서 애플리케이션이 동작하기 시작했을 때, 소켓을 만들고 접속 대기상태로 만듬
  - 클라이언트 측은 사용자가 무언가 조치를 취하여 서버에 액세스하는 동작이 시작될 때  일반적으로 패킷을 작성
- 클라이언트가 서버를 향해 접속 동작 실행  
  - TCP 헤더 전송(SYN=1, Sequence 초기값, 윈도우값)
- 서버에 도착하면 서버에서 SYN을 1로 만든 TCP 헤더가 돌아옴 
  - TCP 헤더(시퀀스 번호, 윈도우, ACK 번호)
- 데이터 송수신 단계
  - 웹의 경우 클라이언트에서 서버에 리퀘스트 메세지 송신
  - 적당한 크기로 분할한 후 TCP 헤더(시퀀스 번호 포함)를 맨 앞에 부가하여 서버에 보냄
  - 서버는 ACK 번호를 반송. 필요하면 윈도우 값도 같이 반송
  

### 용어 정리
- 패킷
  - 네트워크에서 데이터는 수십 바이트에서 수천 바이트 정도의 작은 덩어리로 분할되어 운반됨  
    이 작은 덩어리를 패킷이라고 함
- MAC 주소
  - IEEE에서 표준화된 LAN 방식의 기기는 모두 같은 형식의 주소를 사용하며 이 주소를 MAC 주소라고 부름  
