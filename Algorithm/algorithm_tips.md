## python algorithm tips
- `sys.stdin.readline()`은 맨 끝의 개행 문자를 반환함  
  따라서 print 함수 내에 그대로 넣으면 개행문자를 출력한 다음 한번 더 개행됨
- FIFO, FILO 등을 수행한다 싶으면 stack을 응용할 수 있음
- 입력의 범위가 주어질 때, 최대, 최소 값은 반드시 테스트해보기
- `while` 문 수행시, 첫 줄에 먼저 check 하고 본문을 수행하자  
  마지막에 check 로직을 넣으면, 예외 잡기가 어려울 수 있음
- 최소, 최대, 0, 1은 반드시 체크 해야 함
- 반올림: `round`, 버림: `int`, 올림: `ceil`
- divide & conquer 수행시, mid 값을 구할 때 항상 // 2를 통해서 구하므로 버림이 됨  
  이 상태에서 (left, mid-1), (mid, right)로 divide하게 되면 무한 루프  
  (0, 1) -> (0, 0), (0, 1)로 무한 루프가 생기게 됨
- 시스템의 가장 큰 값과 가장 작은 값은 `-sys.maxsize`, `sys.maxsize`임  
- 파이썬에서 대부분의 우선순위 큐 풀이에는 거의 항상 `headq` 모듈을 사용함
- 조심해야 할 것은 `headq` 모듈을 사용할 때 중복된 값은 넣을 수 없음

### python 알고리즘 시간 복잡도
- 리스트 중간에 끼워넣거나 빼는 것은 O(N)
- 퀵소트를 직접 구현하면 거의 O(N^2)이 될 확률이 높음. 왠만하면 내장 정렬 함수를 사용하자(내장 정렬 함수는 팀소트 정렬)
- 격자에서 탐색시, 범위 체크
- DP를 Top -> Down 방식으로 할 때는 memorization 필수
- <b>BFS 수행시, queue에서 뺀 다음 확인이 아닌, 큐에서 빼기 전에 방문 체크를 해야 함</b>
- `list.pop`, `list.index`, `list.insert`, `x in list`, `list[:-1]` 전부 O(N)
- list를 queue, deque으로 사용하면 안됨. 반드시 collections.deque를 써야 함
- 정렬된 시퀀스를 검색할 때는 `bisect`를 사용하자

### 최대값과 최소값
- 파이썬에서의 최대값과 최소값은 다음과 같음
  - `-sys.maxsize`
  - `sys.maxsize`
- float를 이용해 다음과 같이 무한대 값을 지정하는 방법도 있음  
  - `mx = float('-inf')`
  - `mn = float('inf')` 
- 가장 좋지 않은 방법은 다음과 같이 999999 같은 값을 지정하는 것
- 파이썬의 숫자형은 임의 정밀도(Arbitary-Precisio)을 지원하며,  
  사실상 무한대의 값을 지정할 수 있음
- 아무리 큰 수를 지정할지라도 임의의 값을 초깃값으로 지정하는 것은 지양해야함
- 대개 코딩 플랫폼에서는 범위가 주어져 있으므로, 해당 범위를 잘 보고  
  최대, 최솟값을 지정하면 됨

### 런너 기법
- 런너(Runner)는 연결 리스트를 순회할 때 2개의 포인터를 동시에 사용하는 방법
- 한 포인터가 다른 포인터보다 앞서게 하여 병합 지점이나 중간 위치, 길이 등을 판별할 때 유용하게 사용할 수 있음
- 2개의 포인터는 빠른 런너(Fast runner), 느린 런너(Slow Runner)라고 부르는데, 대개 빠른 런너는 두 칸씩 건너뛰고ㄴ, 느린 런너는 한 칸씩 이동하게 함
- 이 때 빠른 런너가 연결 리스트의 끝에 도달하면, 느린 런너는 정확히 연결 리스트의 중간 지점을 가리키게 됨
- 이 때 값을 비교하거나 뒤집기를 시도하는 등 여러모로 활용이 가능

### 파이썬 전역 인터프리터 락(GIL)
- '파이썬은 왜 느린가?' 라는 질문에 가장 자주 듣게 되는 얘기가 전역 인터프리터 락(GIL)이 아닐까 싶음
- 파이썬의 최초 공식 구현체인 CPython은 개발초기에 번거로운 동시성 관리를 편리하게 하고 스레드 세이프하지 않은 CPython의 메모리 관리를 쉽게 하기 위해, GIL로 파이썬 객체에 대한 접근을 제한하는 형태로 설계
- GIL은 하나의 스레드가 자원을 독점하는 형태로 실행

### 연결 리스트
- 가장 기본이 되는 대표적인 선형 자료구조 중 하나
- 다양한 추상 자료형 구현의 기반이 됨
- <b>배열과는 달리 특정 인덱스에 접근하기 위해서는 전체를 순서대로 읽어야 하므로 상수 시간에 접근할 수 없음. 즉, 탐색에는 O(n) 소요</b>
- 반면 시작, 끝 지점에 아이템을 추가하거나 삭제, 추출은 O(1)이 걸림

### 해쉬 테이블
- 해시 테이블 또는 해시 맵은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추상 자료형을 구현하는 자료 구조
- 해시 테이블의 가장 큰 특징은 대부분의 연산이 분할 상환 분석에 따른 시간 복잡도가 O(1)이라는 점
- 덕분에 데이터 양에 관계 없이 빠른 성능을 기대할 수 있다는 장점이 있음

### 해시
- 해시 함수란 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수를 말함
- 예를 들어 입력값은 ABC, 1234BC, AF32B로 각각 3글자, 6글자, 5글자이지만, 화살표로 표시한 특정 함수를 통과하면 2바이트의 고정 크기 값으로 매핑됨
~~~
ABC -> A1
1234BC -> CB
AF32B -> D5
~~~
- 해시 테이블을 인덱싱하기 위해 이처럼 해시 함수를 사용하는 것을 해싱이라고 함
- 해싱은 최적의 검색이 필요한 분야에서 사용되며, 심볼 테이블 등의 자료구조를 구현하기에도 적합함