## python algorithm tips
- `sys.stdin.readline()`은 맨 끝의 개행 문자를 반환함  
  따라서 print 함수 내에 그대로 넣으면 개행문자를 출력한 다음 한번 더 개행됨
- FIFO, FILO 등을 수행한다 싶으면 stack을 응용할 수 있음
- 입력의 범위가 주어질 때, 최대, 최소 값은 반드시 테스트해보기
- `while` 문 수행시, 첫 줄에 먼저 check 하고 본문을 수행하자  
  마지막에 check 로직을 넣으면, 예외 잡기가 어려울 수 있음
- 최소, 최대, 0, 1은 반드시 체크 해야 함
- 반올림: `round`, 버림: `int`, 올림: `ceil`
- divide & conquer 수행시, mid 값을 구할 때 항상 // 2를 통해서 구하므로 버림이 됨  
  이 상태에서 (left, mid-1), (mid, right)로 divide하게 되면 무한 루프  
  (0, 1) -> (0, 0), (0, 1)로 무한 루프가 생기게 됨
- 시스템의 가장 큰 값과 가장 작은 값은 `-sys.maxsize`, `sys.maxsize`임  


### python 알고리즘 시간 복잡도
- 리스트 중간에 끼워넣거나 빼는 것은 O(N)
- 퀵소트를 직접 구현하면 거의 O(N^2)이 될 확률이 높음. 왠만하면 내장 정렬 함수를 사용하자
- 격자에서 탐색시, 범위 체크
- DP를 Top -> Down 방식으로 할 때는 memorization 필수
- <b>BFS 수행시, queue에서 뺀 다음 확인이 아닌, 큐에서 빼기 전에 방문 체크를 해야 함</b>
- `list.pop`, `list.index`, `list.insert`, `x in list`, `list[:-1]` 전부 O(N)
- list를 queue, deque으로 사용하면 안됨. 반드시 collections.deque를 써야 함

### 최대값과 최소값
- 파이썬에서의 최대값과 최소값은 다음과 같음
  - `-sys.maxsize`
  - `sys.maxsize`
- float를 이용해 다음과 같이 무한대 값을 지정하는 방법도 있음  
  - `mx = float('-inf')`
  - `mn = float('inf')` 
- 가장 좋지 않은 방법은 다음과 같이 999999 같은 값을 지정하는 것
- 파이썬의 숫자형은 임의 정밀도(Arbitary-Precisio)을 지원하며,  
  사실상 무한대의 값을 지정할 수 있음
- 아무리 큰 수를 지정할지라도 임의의 값을 초깃값으로 지정하는 것은 지양해야함
- 대개 코딩 플랫폼에서는 범위가 주어져 있으므로, 해당 범위를 잘 보고  
  최대, 최솟값을 지정하면 됨

### 런너 기법
- 런너(Runner)는 연결 리스트를 순회할 때 2개의 포인터를 동시에 사용하는 방법
- 한 포인터가 다른 포인터보다 앞서게 하여 병합 지점이나 중간 위치, 길이 등을 판별할 때 유용하게 사용할 수 있음
- 2개의 포인터는 빠른 런너(Fast runner), 느린 런너(Slow Runner)라고 부르는데, 대개 빠른 런너는 두 칸씩 건너뛰고ㄴ, 느린 런너는 한 칸씩 이동하게 함
- 이 때 빠른 런너가 연결 리스트의 끝에 도달하면, 느린 런너는 정확히 연결 리스트의 중간 지점을 가리키게 됨
- 이 때 값을 비교하거나 뒤집기를 시도하는 등 여러모로 활용이 가능