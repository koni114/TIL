# chapter06 함수
- 이 장의 초점은  non-formal하게 함수란 무엇이며, 함수가 어떻게 동작하는지를 정확하게 이해하도록 하는 것
- <b>R을 이해하는 데 가장 중요한 점은 함수 그 자체도 객체라는 점</b>

## 6.1 함수의 구성요소
- 모든 함수는 세 부분으로 구성되어 있음
  - `body()`, 함수 안에 쓰인 코드
  - `formal()`, 함수 호출을 제어하는 인자 목록
  - `environment()`, 함수의 변수에 대한 위치 지도
- <b>환경(environment)</b>가 보이지 않는다는 것은 그 함수가 <b>전역 환경(global environment)</b>에서 생성되었다는 것을 보여줌
~~~r
f <- function(x) x^2
f

formals(f)
#> $x
body(f)
#> x^2
environment(f)
#> <environment: R_GlobalEnv>
~~~
- `body()`, `formals()`, `enviroment()`의 할당 형식은 함수를 수정하는데도 사용할 수 있다
- 함수 또한 `attributes()`로 임의의 추가 속성을 가질 수 있음
- base R에서 사용된 속성 중 하나는 <b>소스 참조(source reference)</b>의 약자인 `srcref` 인데, 이것은 함수를 생성하는데 사용된 소스 코드를 가리킴
- `srcref`는 `body()`와 달리 코드 주석과 기타의 형식 등을 담고 있음
- 함수에는 속성을 추가로 부여할 수 있다. 예를 들어 <b>`class()`를 설정하고 개인화된 print() 메소드를 추가할 수 있음</b>

### 6.1.1 원시 함수(primitive function)
- 함수가 3가지 요소를 가진다는 것에는 예외가 있음. 
- `sum()`과 같은 원시 함수(primitive function)는 `Primitive()`로 직접 C 코드를 호출하는데, 이와 같은 함수에는 R 코드가 없음
- 따라서 `formals()`, `body()`, `environment()`가 모두 NULL임
~~~r
sum
#> function (..., na.rm = FALSE) .Primitive("sum")

formals(sum)
#> NULL

body(sum)
#> NULL

environment(sum)
#> NULL
~~~
- 원시 함수는 base 패키지에서만 찾을 수 있으며 이 함수는 저수준에서 동작하기 때문에 보다 효율적이고 인자 매칭(ex) switch와 call)에 대해 다른 규칙을 가질 수 있음
- 하지만 원시함수는 R의 다른 함수와 다르게 움직이는 부정적 효과가 있음
- 따라서 R 코어팀은 다른 대안이 존재하지 않는 경우를 제외한다면 이런 원시 함수를 생성하지 않음

## 6.2 렉시칼 스코핑(lexical scoping)
- <b>스코핑(scoping)</b>은 R이 심볼 값을 찾는 방법을 지배하는 규칙들의 집합  
  (R에서 값을 찾는 범위를 말함. ex) 해당 변수는 전역 변수인가 지역 변수인가? 등)
- 다음 사례에서 스코핑은 R이 변수 x에 그 x의 값 10을 적용하는 규칙 집합
~~~r
x <- 10
x
#> [1] 10
~~~
- 스코핑에 대한 이해는 다음을 수행하는 데 도움이 됨
  - 함수들을 합성하여 도구를 구축(9장)
  - 일반적인 평가 규칙을 억제하고 비표준적 평가를 실행(12장)
- R의 스코핑 방법은 언어 수준에서 자동으로 구현되는 <b>렉시칼 스코핑</b>과 인터랙티브한 분석 중 타이핑을 효율적으로 하기 위한 함수 선택에 사용되는 <b>다이내믹 스코핑</b>으로 나눌 수 있음
- 여기에서는 함수 생성과 밀접하게 관련이 있는 렉시칼 스코핑을 다룸
- 렉시칼 스코핑은 함수가 호출되었을 때가 아니라 생성되었을 때 중첩되는(nested) 방식에 따라 심볼 값을 찾음
- 렉시칼 스코핑을 사용하면 변수의 값을 어디에서 찾아야 할지 알아내기 위해 함수를 호출하는 방법을 알아야 할 필요가 없음
- 단지 함수의 정의만 살펴보면 됨
- R이 도입한 렉시칼 스코핑의 이면에는 다음의 네 가지 기본적인 원칙이 있음
  - 이름 마스킹(name masking)
  - 함수와 변수(functions vs variables)
  - 새롭게 시작(a fresh start)
  - 동적 탐색(dynamic lookup)

### 6.2.1 이름 마스킹(name masking)
- 다음 예제는 렉시칼 스코핑의 가장 기초적인 원칙을 설명하는 것으로, 어떻게 출력될 것인지 쉽게 예측할 수 있어야 함
~~~r
f <- function(){
    x <- 1
    y <- 2
    c(x, y)
}
f()
rm(f)
~~~
- 만약 함수 내에 이름(변수명)이 정의되지 않았다면, R은 한 수준 위(여기서는 global environment)를 탐색할 것임을 다음 예제에서 확인 가능
~~~r
x <- 2
g <- function(){
    y <- 1
    c(x, y)
}
g()
~~~
- 어떤 함수가 다른 함수안에 정의되어도 이와 동일한 규칙이 적용
- 현재 함수의 내부를 탐색하고 난 후 함수가 정의된 곳을 찾고, 이를 반복해 전역 환경에까지 가는 모든 방법을 거치고 로딩된 다른 패키지들을 찾음
- 다음 예제를 실행해보자
~~~r
x <- 1
h <- function(){
    y <- 2
    i <- function(){
        z <- 3
        c(x, y, z)
    }
    i()
}
h()
rm(x, h)
#> [1] 1 2 3
~~~
- 여기서는 클로저가 스코핑과 어떻게 상호작용하는지만 간단히 살펴볼 것임 
  아래의 함수 `j()`는 함수를 반환함. 이 함수를 호출할 때 무엇이 반환될 것 같은가?
~~~r
j <- function(x){
    y <- 2
    function(){
        c(x, y)
    }
}
k <- j(1)
k()
rm(j, k)
~~~
- R은 함수가 호출된 이후에 어떻게 y의 값을 알 수 있을까? 이것은 j(1)을 호출하는 순간 그 정의된 환경을 유지하면서 그 환경 내에 y의 값을 포함하기 때문

### 6.2.2 함수와 변수
- 연관된 값의 유형에 대한 고려 없이 앞과 동일한 원칙이 적용됨
- 함수 검색은 변수를 찾는 방법과 동일한 방법으로 동작
~~~r
# 기존 먼저 선언되었던 (l)은 무시
l <- function(x) x + 1 #- (1) 
m <- function(){
    l <- function(x) x * 2  #- (2)
    l(10) 
}
m()
#> [1] 20
rm(l, m)
~~~
- 함수의 경우 규칙에 대한 한 가지 작은 <b>변형(tweak)</b>이 있다
- 내가 사용하고자 하는 함수와 동일한 명으로 변수로 사용되면, 검색하는 동안 R은 함수가 아닌 객체들을 무시할 것임
- 다음 예제에서 n은 R이 함수를 검색하는지, 변수를 검색하는지에 따라 다른 값을 가짐
~~~r 
n <- function(x) x / 2 
o <- function(){
    n <- 10
    n(n)
}
o()
rm(n, o)
~~~  
- 가장 좋은 방법은 함수명과 변수명을 동일하게 사용을 피하는 것

### 6.2.3 새롭게 시작(a fresh start)
- 함수 실행 간 값에는 어떤 일이 일어날까
- 다음 예제의 함수를 실행했을 때 어떤 일이 일어날까? 두 번째에서는 어떤 일이 발생하는가?
~~~r 
j <- function(){
    if(!exists("a")){
        a <- 1
    }else{
        a <- a + 1
    }
    print(a)
}
j()  #- 항상 1을 return
j()
rm(j)
~~~
- 매번 1을 호출하는 이유는 함수가 매번 호출될 때 마다 호스트를 실행하기 위해 새로운 환경을 생성하기 때문
- 즉 함수 기동은 완벽하게 독립적

### 6.2.4 동적 탐색(dynamic lookup)
- 렉시칼 스코핑은 값들을 탐색하는 시기가 아니라 장소를 판단함
- R은 함수가 생성될 때가 아니라 실행될 때 값을 탐색  
  (환경이 아니라 값임을 주의하자)
- 즉, 함수의 출력이 환경 외부에 있는 객체에 따라 달라질 수 있음을 의미
~~~r
f <- function() x 
x <- 15
f()
#> [1] 15

x <- 20
f()
#> [1] 20
~~~
- 이러한 부분은 오류를 발생시킬 수 있는데, 코드를 작성할 때 철자에 오류가 있다면  
  함수를 생성할 때 오류가 나타나지 않으므로 어떤 변수가 전역 환경에서 정의되는지 따라  
  그 함수를 실행 할 때도 오류가 나지 않을 것임
- 이때 문제를 해결하는 한 가지 방법은 `codetools`의 `findGlobals()` 함수를 사용하는 것
- 이 함수는 특정 함수의 모든 외부 의존성(dependency)을 나열
~~~r
f <- function() x + 1
codetools::findGlobals(f)
#> [1] "+" , "x"
~~~  
- 또 다른 방법은 `emptyenv()`로 함수의 환경을 아무것도 담고 있지 않는 환경(공환경)으로 직접 변경하는 것
~~~r
environment(f) <- emptyenv()
f()
#> Error in f(): could not find function "+"
~~~
- 이는 동작하지 않는데, 왜냐면 R은 `+` 연산자를 포함한 모든 것을 찾을 때 렉시칼 스코핑에 의존하기 때문
- base R 또는 다른 패키지에서 정의된 함수에 항상 의존해야 하기 때문에 완벽한 자기 포함적 함수를 만들 수 없음

## 6.3 모든 연산은 함수 호출
- R에서의 계산을 이해하는 데는 다음 두가지 슬로건이 도움이 될 것임
  - "존재하는 모든 것은 객체다"
  - "발생하는 모든 것은 함수 호출이다"
- (를 다시 정의하는 앞의 사례는 R의 모든 연산이 함수 호출이기 때문에 보이는 것과 상관 없이 동작
- 이 연산자에는 `+`와 같은 삽입 연산자, `for`, `if`, `while`과 같은 흐름 제어 연산자, `[[`, `$`와 같은 서브세팅 연산자 그리고 `{`와 같은 괄호도 포함
- 이 말은 다음 사례에서 각 구문의 쌍이 동일하다는 것을 의미
- `(백틱)으로 예약되거나 허용되지 않는 이름을 가진 함수 또는 변수를 참조할 수 있다는 점에 주의
~~~r
x <- 10; y <- 5
x + y
#> [1] 15

`+`(x, y)
#> [1] 15 

for (i in 1:2) print(i)
#> [1] 1 
#> [1] 2

`for`(i, 1:2, print(i))
#> [1] 1 
#> [1] 2

if (i == 1) print("yes!") else print("no.")
#> [1] "no."

`if` (i == 1, print("yes!"), print("no."))
#> [1] "no."

x[3]
#> [1] NA

`[`(x, 3)
#> [1] NA
~~~ 
- 이러한 특수한 함수의 정의를 다시 할 수는 있지만 좋지 않은 생각
- 그러나 유용한 경우도 있는데 예를 들어 dplyr 패키지가 R 표현식을 SQL 표현식으로 번역할 수 있게 해줌
- 이 아이디어를 기존의 <b>R 구현체(construct)</b>를 이용하여 새로운 개념을 간단히 표현할 수 있도록 해주는 <b>도메인 특화 언어(domain specific language)</b>를 생성하기 위해 이 아이디어를 사용
- 특수한 함수를 본래의 함수처럼 다루는 것이 더 유용한 경우가 종종 있음
- 예를 들어 `sapply()`는 다음과 같이 앞에 정의한 함수인 `add()`를 이용하여 각 리스트릐 각 요소에 3을 더할 때 사용할 수 있음
~~~r
add <- function(x, y) x + y 
sapply(1:10, add, 3)
#>  [1]  4  5  6  7  8  9 10 11 12 13
~~~
- 이와 동일한 효과를 내장된 + 함수를 이용해서도 얻을 수 있음
~~~r
sapply(1:5, `+`, 3)
#> [1] 4 5 6 7 8

sapply(1:5, "+", 3)
#> [1] 4 5 6 7 8
~~~
- "(쌍따옴표)+ `(백틱)+ 의 차이에 주의. 앞의 것은 +라는 객체의 값이고 두 번째 것은 + 문자를 포함한 문자열
- 두 번째 코드가 동작하는 이유는 `lapply`가 함수 자체가 아니라 함수의 이름을 받을 수 있기 때문
- `lapply()`의 소스를 읽으면, 주어진 함수의 이름을 찾기s 위해 `match.fun()`을 사용하는 첫 번째 줄을 볼 수 있을 것임
- 보다 유용한 응용은 `lapply()` 또는 `sapply()`를 서브세팅과 결합하는 것
~~~r
x <- list(1:3, 4:9, 10:12)
sapply(x, "[", 2)
#> [1] 2 5 11

# 다음과 동일
sapply(x, function(x) x[2])
#> [1] 2 5 11
~~~

## 6.4 함수 인자
- 함수의 형식 인자(formal arguments)와 실질 인자(actual argument)를 구분하는 것은 유용
- 실질 인자 또는 호출 인자(calling arguments)는 함수를 호출할 때 마다 변하지만, 형식 인자는 하나의 함수 속성
- 이번 절에서는 호출 인자가 형식 인자와 매핑되는 방법, 주어진 인자 목록에서 함수를 호출하는 방법, 기본 인자가 동작하는 방법, 느슨한 평가의 효과를 알아보자

### 6.4.1 함수 호출
- 함수를 호출할 때 위치, 전체 이름, 부분 이름으로 인자를 특정할 수 있음
- 인자는 처음에는 <b>완전 매칭(perfect matching) -> 접두어 매칭(perfix matching) ->
위치로 매칭</b>됨
~~~r 
f <- function(abcdef, bcde1, bcde2){
    list(a = abcdef, b1 = bcde1, b2 = bcde2)
}

str(f(1,2,3))
#> List of 3
#>  $ a : num 1
#>  $ b1: num 2
#>  $ b2: num 3

str(f(2, 3, abcdef = 1))
#> List of 3
#>  $ a : num 1
#>  $ b1: num 2
#>  $ b2: num 3

#- 길이가 긴 인자 이름을 줄여쓸 수 있음
str(f(2, 3, a = 1))
#> List of 3
#>  $ a : num 1
#>  $ b1: num 2
#>  $ b2: num 3

#- 불분명한 줄여쓰기 때문에 다음의 코드는 동작하지 않음
str(f(1, 3, b = 1))
#> Error in f(1, 3, b = 1) : argument 3 matches multiple formal arguments
~~~
- CRAN에 공개하길 원하는 패키지 코드를 작성하고 있다면 반드시 완전한 이름을 사용
- <b>이름 있는 인자는 이름 없는 인자 뒤에 위치해야 함</b>
- 어떤 함수가 ...를 사용한다면 전체 이름과 함께 ... 뒤에 나열된 인자만을 특정할 수 있음
- 다음이 좋은 사례
~~~r
mean(1:10)
mean(1:10, trim = 0.05)
mean(x = 1:10)
~~~
- 다음은 혼란스럽다
~~~r
mean(1:10, n = T)
mean(1:10, , FALSE)
mean(1:10, 0.05)
mean(, TRUE, x = c(1:10, NA))
~~~

### 6.4.2 주어진 인자 목록에서 함수 호출
- 함수 인자에 전달하고자 하는 목록이 있다고 해보자
~~~r
args <- list(1:10, na.rm = T)
#> [[1]]
#>  [1]  1  2  3  4  5  6  7  8  9 10

#> $na.rm
#> [1] TRUE
~~~
- 이 인자를 어떻게 `mean()`에 보낼 수 있을까? 이 때 `do.call()`가 필요함
~~~r 
do.call(mean, list(1:10, na.rm = T))
#> 5.5 
#- 다음과 동일
mean(1:10, na.rm = T)
~~~

### 6.4.3 기본값과 결측 인자
- R의 함수 인자는 기본값을 가질 수 있음
~~~r
f <- function(a = 1, b = 2){
    c(a, b)
}
f()
#> [1] 1 2 
~~~
- R에서 인자는 느슨하게 평가되기 때문에 기본값이 다른 인자로 정의될 수 있음
~~~r
g <- function(a = 1, b = a * 2){
    c(a, b)
}
g()
#> [1] 1 2 

g(10)
#> [1] 10 20
~~~
- 기본 인자는 함수 내에 생성된 변수로도 정의될 수 있음  
- 이것은 base R 함수에서 자주 사용되지만, 완벽하게 소스 코드를 읽지 않으면 기본값이  
  무엇인지 알 수 없기 때문에 좋지 않은 방법
~~~r 
h <- function(a = 1, b = d){
    d <- (a + 1) ^ 2
    c(a, b)
}
h()
#> [1] 1 4 

h(10)
#> [1] 10 121
~~~
- `missing()` 함수를 사용하면 인자가 제공되었는지 여부를 판단할 수 있음
~~~r
i <- function(a, b){
    c(missing(a), missing(b))
}
i()
#> [1] TRUE TRUE

i(a = 1)
#> [1] FALSE TRUE

i(b = 2)
#> [1] TRUE FALSE

i(1, 2)
#> [1] FALSE FALSE
~~~
- 가끔 평범하지 않은 기본값을 추가하길 원할 경우 계산을 위해 몇 줄의 코드가 추가로 필요할 수 있음
- 함수 정의 그 코드를 삽입하는 대신, 조건부 계산을 위한 `missing()`를 사용할 수 있음
- 그러나 문서를 주위 깊게 읽지 않으면 어떤 인자가 필수적이고, 어느 것이 선택적인지 알기 어려움
- <b>따라서 기본값을 NULL로 설정하고 인자가 제공되었는지 확인하려면 is.null()을 사용</b> 

### 6.4.4. 지연 평가(Lazy evaluation)
- <b>인자는 오로지 실제로 사용될 때 평가됨</b>
~~~r
f <- function(x){
    10
}
f(stop("This is an error!"))
#> [1] 10
~~~
- 인자가 평가되었는지 확인하려면 `force()`를 사용해야 함
~~~r
f <- function(x){
    force(x)
    10
}
f(stop("This is an error!"))
#-  Error in force(x) : This is an error! 
~~~
- 이는 `lapply()`나 루프로 클로저를 생성할 때 중요
~~~r 
add <- function(x){
  function(y) x + y
}

adders <- lapply(1:10, add) #- lapply로 x 변수 값을 환경에서 정의함
adders[[1]](10)             #- (n) 입력으로 y 변수 값을 선언 
#> [1] 11


adders[[10]](10)
#> [1] 20
~~~
- x는 adder 함수 중 하나를 처음 호출할 때 지연 평가됨
- 이때 루프는 완전히 완료되었고, x의 마지막 값은 10
- 따라서 모든 `adder` 함수는 그 입력에 10을 더하지만, 이것은 원하는 바가 아님
- 이 문제를 해결하려면 평가를 직접 강제해야 함
~~~r
add <- function(x){
  force(x)
  function(y) x + y
}

adders2 <- lapply(1:10, add)
adders2[[1]](10)
#> [1] 11

adders2[[20]](10)
#> [1] 20
~~~
- 이 코드는 정확히 다음과 일치
~~~r
add <- function(x){
    x
    function(y) x + y
}
~~~
- 왜냐면 `force` 함수는 `force <- function(x) x`로 정의되어 있기 때문
- 그러나 이 함수를 사용하는 이유는 우연히 x를 입력한 것이 아니라 강제 평가를 하고 있다는 것을 분명하게 나타냄
- <b>기본 인자는 함수 내에서 평가됨</b>
- <b>이것은 표현식이 현재 환경에 의존한다면 그 결과가 기본값을 사용하는지, 명백히 어느 하나를 제공하는지에 따라 달라진다는 것을 의미</b> 
  - 기본값을 그대로 사용하는 경우(parameter에 따로 선언 x)  
    --> 함수 환경 내에서 `ls()`가 평가됨
  - parameter에 값을 직접 선언하는 경우  
    --> `ls()` 전역환경에서 평가됨
~~~r
f <- function(x = ls()){
    a <- 1
    x
}

# ls()가 f 내에서 평가됨
f()

#> [1] "a" "x"
# ls()가 전역 환경에서 평가됨
f(ls())
#> [1] "add"     "adders"  "adders2" "f"       "f1"      "f2"      "funs"    "g"       "h"       "objs"    "tt"  
~~~
- 기술적으로 말하면 평가되지 않는 인자는 <b>프로미스(promise)</b> 또는 <b>썽크(thunk)</b>라고 불림
- 프로미스는 다음 두 가지로 구성
  - 지연된 계산을 가져오는 표현식
  - 표현식이 생성, 평가되어야 하는 환경 
- <b>표현식이 처음 프로미스에 접근할 때 그 표현식은 생성된 환경에서 평가됨</b>
- 이 값은 캐시되므로 평가된 프로미스에 대한 그 이후의 값을 다시 계산하지 않음
- `pryr::promise_info()`를 사용하면 프로미스에 관한 보다 많은 정보를 찾아볼 수 있음
- 약간의 C++ 코드를 사용하여 평가 과정을 거치지 않고 프로미스에 관한 정보를 추출하는 데 사용하지만, 순수한 R 코드에서는 사용할 수 없음
- 이러한 지연 연산은 `if` 구문에서 유용함
- 아래의 두 번째 구문은 처음이 참일 때만 평가됨. 그렇지 않다면 NULL > 0은 길이가 0인 논리형 벡터고 if에 유효한 입력이 아니기 때문에 오류를 반환하게 됨
~~~r
x <- NULL
if (!is.null(x) && x > 0){

}
~~~ 
- `&&`를 직접 구현할 수도 있음
~~~r
`&&` <- function(x, y){
if (!x) return(FALSE)
if (!y) return(FALSE)
TRUE
}

a <- NULL>
!is.null(a) && a > 0
#> [1] FALSE 
~~~
- 만약 지연 평가가 이루어지지 않는다면, a가 NULL 일때 a > 0을 테스트하는 것처럼  
  x와 y 둘 모두 항상 평가 될 것이므로 이 함수는 지연 평가가 없으면 에러 발생
- 가끔 `if` 구문을 일시에 모두 제거하기 위해 느슨함을 이용할 수 있음
~~~r
if (is.null(a)) stop("a is null")
#> Error: a is null
~~~
- 예를 들어 위와 같은 방법 대신 아래와 같이 쓸 수 있음
~~~r
!is.null(a) || stop("a is null!")
~~~

### 6.4.5 ...
- `...`라는 특수한 인자는 매칭되지 않은 어떤 인자와도 매칭될 수 있기 때문에 쉽게 다른 함수에  적용할 수 있음
- 다른 함수를 호출하기 위해 인자를 선택하길 원하지만, 가능한 이름을 사전에 정의하기 원치 않을 때 유용
- `...`는 개별적인 메소드를 보다 유연하게 해주는 <b>S3 제너릭 함수(S3 generic functions)</b>와 결합하여 사용
- 기본 `plot()`함수는 `...` 인자를 비교적 복잡하게 사용함
- `plot()`는 x, y, `...` 를 인자로 가지는 <b>제너릭 메소드(generic method)</b>임
- 가장 단순한 `plot()`의 기동은 `...`를 포함한 보다 많은 인자를 가지는 `plot.default()`를 호출하게 됨
- 다시 말해 `...`이 `par()` 도움말에 나열되어 있는 다른 그래픽 파라미터를 허용한다는 것을 알 수 있음
- 이에 따라 다음과 같은 코드를 작성할 수 있음
~~~r
plot(1:5, col = "red")
plot(1:5, cex = 5, pch = 20)
~~~
- 이것은 `...`의 장점과 단점을 동시에 보여 줌
- 즉 이와 같은 방법은 `plot()`을 매우 유연하게 해주지만 사용법을 이해하려면 문서를 주의 깊게 살펴봐야 함
- 이 밖에 `plot.default`의 소스 코드를 읽어보면 문서에 설명되어 있지 않은 기능들이 있다는 것을 발견할 수 있음
- `Axis()`와 `box()`에 다른 인자를 전달하는 것도 가능
~~~r
plot(1:5, bty = "u")
plot(1:5, labels = FALSE)
~~~
- `...`를 보다 수월하게 작업하기 위한 형태로 파악하려면 `list(...)`를 사용해야 함
~~~r
f <- function(...){
    names(list(...))
}
f(a = 1, b = )
#> [1] "a" "b"
~~~
- `...`의 사용은 수고를 감수해야 함
- 즉 어떤 표기된 인자도 오류를 나타내지 않을 것임으로 `...` 뒤의 모든 인자는 완전한 이름이 있어야 함
- 이것은 인지하지 못한 오타를 만들 수 있게 함
~~~r
sum(1, 2, NA, na.rm = T)
#> [1] NA
~~~
- 인자의 입력은 암묵적인 것보다 명시적인 것이 더 좋으므로 사용자에게 추가적 인자의 목록을 제공할 것을 요구할 수 있음
- 이것은 복수의 추가적 함수와 함께 `...`를 사용하고자 하는 경우 확실히 더 쉬움

## 6.5 특수한 호출
- R은 함수를 호출하는 특수한 유형의 추가 구문 두 가지를 지원
- <b>삽입 함수(infix functions)</b>와 <b>대체 함수(replacement functions)</b>가 그 둘

### 6.5.1 삽입 함수
- 대부분의 R 함수는 접두 연산자(prefix operators)이므로 함수의 이름이 가장 앞에 옴
- 그리고 `+` 또는 `-`와 같이 함수명이 그 인자 사이에 오는 <b>삽입 함수(infix function)</b>를 생성할 수도 있음
- 모든 사용자 생성 삽입 함수는 %로 시작하고 끝나야 함
- R에서는 다음과 같이 미리 정의된 삽입 함수가 있음
  - `%%`, `%*%`, `%/%`, `%in%`, `%o%`, `%x%`
  - %가 필요하지 않은 내장 삽입 함수 : `::`, `:::`, `$`, `@`, `^`, `*`, `/`, `+`..등
- 예를 들어, 문자열을 서로 붙이는 새로운 연산자를 생성할 수 있음
~~~r
`%+%` <- function(a, b) paste(a, b)
"new" %+% "string"
#> [1] "new string"
~~~ 
- 함수를 생성할 때 그 이름은 특별한 것이기 때문에 반드시 `(백틱) 내에 이름을 두어야 함
- 이것은 단지 본래의 함수 호출을 위한 <b>편의 표기법(syntactic sugar)</b>임
- R과 관련해서 이 두 가지 표현 사이의 차이는 없음
~~~r
"new" %+% "string"
#> [1] "new string"

`%+%`("new", "string")
#> [1] "new string"
~~~
~~~r
1 + 5
#> [1] 6

`+`(1, 5)
#> [1] 6 
~~~
- 삽입 함수의 이름은 정규의 R 함수에 비해서 비교적 유연
- 즉 삽입 함수는 어떤 문자 시퀀스도 포함할 수 있음(%는 제외)
- 함수를 정의하기 위해 사용된 문자열의 어떤 특별한 문자에서 벗어날 필요가 있을 수 있지만  
  그것을 호출할 때는 아님
~~~r
`% %` <- function(a, b) paste(a, b)
`%'%` <- function(a, b) paste(a, b)
`%/\\%` <- function(a, b) paste(a, b)

"a" % % "b"
#> [1] "a b"

"a" %"'"% "b"
#> [1] "a b"

"a" %/\% "b"
#> [1] "a b"
~~~
- R의 기본적 우선순위 규칙은 삽입 연산자가 왼쪽에서 오른쪽으로 구성된다는 것을 의미
~~~r
`%-%` <- function(a, b) paste0("(", a, " %-% ", b, ")")
"a" %-% "b" %-% "c"
#>  "((a %-% b) %-% c)"
~~~
- 매우 자주 사용되는 삽입 함수는 Ruby의 || 논리 or 연산자로부터 영감을 받은 것이지만  
  R과는 다소 다르게 동작함

### 6.5.2 대체 함수
- <b>대체 함수(replacement functions)</b>는 함수가 그 함수의 인자들을 수정하는 것처럼 동작하고, `xxx<-` 라는 특수한 함수명을 가짐
- 대체 함수는 두 개의 인자(x와 value)를 가지며, 수정된 객체를 반환
- 예를 들어, 다음 함수는 벡터의 두 번째 요소를 수정
~~~r
`second<-` <- function(x, value){
    x[2] <- value
    x
}
x <- 1:10
second(x) <- 5L
x
#>  [1]  1  5  3  4  5  6  7  8  9 10
~~~
- 대체 함수가 그 함수의 인자를 수정하는 것처럼 동작한다고 말한 이유는 <b>실제로 수정된 사본을 생성하기 때문</b> 
- 기저 객체의 메모리 주소를 찾기 위해 `pryr::address()`를 사용하면, 이를 보다 자세히 알아볼 수 있음
~~~r
library(pypr)

x <- 1:10
address(x)
#> [1] "0x2b97c38"

second(x) <- 6L
address(x)
#> [1] "0x38bf498"
~~~
- `.Primitive()`를 사용하여 구현된 내장 함수는 그 자리에서 수정할 수 있음  
(그 자리에서 수정할 수 있다는 것은 복사 사본이 생기지 않는다는 의미)
~~~r
x <- 1:10
address(x)
#> [1] "0x2930c48"

x[2] <- 7L
address(x)
#> [1] "0x20d8ff08"
~~~
- 성능상 의미 있는 차이를 가지기 때문에 이러한 행동을 인지하는 것은 중요
- <b>추가 인자를 삽입하려면 그 인자가 x와 value 사이에 있어야 함</b>  
  (아래 예제에서는 position이 x와 value 인자 사이에 있음)
~~~r
`modify<-` function(x, position, value){
    x[position] <- value
}
modify(x, 1) <- 10
x
#> [1] 10 6 3 4 5 6 7 8 9 10
~~~
- `modify(x, 1) <- 10`을 호출할 때 R은 이면에서 다음과 같이 동작한다
~~~r
x <- `modify<-`(x, 1, 10)
~~~
- 이는 다음과 같이 할 수 없다는 것을 의미
~~~r
modify(get("x"), 1) <- 10
~~~
- 왜냐하면 유효하지 않은 코드가 되기 때문
~~~r
get("x") <- `modify<-`(get("x"), 1, 10)
~~~
- 대체와 서브세팅을 결합하여 사용하는 것이 좋음
~~~r
x <- c(a = 1, b = 2, c = 3)
names(x)
#> [1] "a" "b" "c"

names(x)[2] <- "two"
names(x)
~~~
- 이것이 동작하는 이유는 `names(x)[2] <- "two"`라는 표현식이 이미 작성했던 것처럼 평가되기 때문
~~~r
`*tmp*`    <- names(x)
`*tmp*`[2] <- "two"
names(x)   <- `*tmp*`
~~~
- 실제로 *tmp*라는 지역변수가 생성되고, 이후에 제거됨

## 6.6 반환값
- 함수 내에서 평가된 마지막 표현식은 함수의 최종 <b>반환값(return value)</b>이 됨
~~~r
f <- function(x){
    if(x < 10){
        0
    }else{
        10
    }
}
f(5)
#> [1] 0

f(15)
#> [1] 10
~~~
- 일반적으로 오류나 단순한 함수의 경우처럼 일찍 반환받는 경우 `return()`을 사용하는 것이 좋은 코딩 스타일
- 이런 프로그래밍 스타일은 들여쓰기 수준을 감소시키고, 지역적으로 함수를 파악할 수 있기 때문에 함수를 이해하기 쉽게 만들어 줌 
~~~r
f <- function(x, y){
    if (!x) return(y)

    #- 여기에 복잡한 프로세스 삽입
}
~~~
- 함수는 오로지 하나의 객체만 반환할 수 있음
- 이것이 한계가 아닌 이유는 여러 객체를 담고 있는 리스트도 반환할 수 있기 때문
- 가장 이해하고 추론하기 쉬운 함수는 <b>순수 함수(pure function)</b>임
- 순수 함수는 항상 같은 입력에 같은 출력을 매핑하고, 작업 공간에 다른 영향을 미치지 않음  
  다시 말해, 순수 함수는 side effect를 갖고 있지 않음
- 즉 순수 함수는 반환하는 값 이외에는 현재 상태에 어떤 영향도 미치지 않음
- R은 한가지 side effect에서 사용자를 보호하는데, 대부분의 R 객체는 <b>수정 후 복사 시맨틱스</b>를 가짐. 따라서 함수 인자를 수정하는 것은 원래의 값을 변화시키지 않음
~~~r
f <- function(x){
    x$a <- 2
    x
}
x <- list(a = 1)
f(x)

#> $a
#> [1] 2

x$a
#> [1] [1]
~~~
- 수정-후-복사 규칙에는 환경 클래ㅡ와 참조 클래스라는 두 가지 중요한 예외가 존재
- 이 둘은 그대로 수정 할 수 있으므로 이것과 관련된 작업을 할 때는 신중해야 함
- 이는 함수의 입력을 수정할 수 있는 Java와는 확연히 다름
- 대부분의 base R 함수는 몇 가지 주의할 만한 예외를 가지면 순수 함수임
  - `library()`는 패키지를 로드하여 검색 경로를 수정
  - `setwd()`, `Sys.setenv()`, `Sys.setlocale()`은 각각 작업 디렉토리, 환경 변수, 로케일을 변경함
  - `plot()` 및 이와 관련된 함수는 그래픽 출력을 만듬 
  - `write()`, `write.csv()`, `saveRDS()` 등은 출력을 디스크에 저장
  - `options()`와 `par()`는 전역 설정을 수정
  - S4 관련 함수는 클래스와 메소드에 대한 전역적 표를 수정
  - <b>난수 생성자(random number generators)</b>는 실행할 때마다 매번 다른 수를 만들어 냄
- 일반적으로 파급 효과를 최소화하고, 순수 함수와 그렇지 않은 함수를 구분함으로써 파급 효과의 풋프린트(footprint)를 최소화하려고 하는 것이 좋음
- 순수 함수는 테스트하기 쉽고, 상이한 R 버전 또는 상이한 플랫폼에서 서로 다르게 동작할 가능성이 적음
- 예를 들어 `ggplot2`의 중요한 원칙 중 하나는 대부분의 연산이 하나의 플롯을 표현하는 객체에서 동작하고, 오로지 마지막 `print`나 `plot`호출만이 실제 플롯을 그려 내는 파급 효과를 가진다는 것 
- 함수는 보이지 않는 값을 반환할 수 있는데, 이런 값은 함수를 호출 할 때 기본적으로 출력되지 않음
~~~r
f1 <- function() 1
f2 <- function() invisible(1)

f1()
#> [1] 1

f2()
f1() == 1
#> [1] TRUE

f2() == 1
#> [1] TRUE
~~~
- 보이지 않는 값을 괄호로 감싸 표시되도록 할 수 있음
~~~r
(f2())

#> [1] 1
~~~
- 보이지 않게 반환하는 가장 공통적인 함수는 `<-` 임
~~~r
a <- 2
(a <- 2)

#> [1] 2
~~~
- 하나의 값을 여러 변수에 할당할 수 있음
~~~r
a <- b <- c <- d <- 2
~~~
- 왜냐하면 다음과 같이 파싱되기 때문
~~~r 
(a <- (b <- (c <- (d <- 2))))
#> [1] 2
~~~

### 6.6.1 나가기
- 함수는 값을 반환할 수 있고 `on.exit()`를 사용하여 끝날 때 시작되는 다른 트리거를 설정할 수 있음  
(`on.exit()`를 이용해서 함수 종료와 동시에 뭔가를 다시 실행가능)
- 이것은 함수가 종료될 때 전역 상태에 대한 변경 사항을 확실히 복원하는 데 사용함
- `on.exit()` 안의 코드는 함수가 종료된 방법, 즉 명시적 초기 반환이나 오류, 단순히 함수 본문의 끝까지 도달했는지의 여부에 관계 없이 실행됨
~~~r
id_dir <- function(dir, code){
    old <- setwd(dir)
    on.exit(setwd(old))

    force(code)
}

getwd()

in_dir("~", getwd())
~~~
- 기본 패턴은 단순
  - 현재 위치를 `setwd()`의 출력으로 파악하여 디렉토리를 새로운 위치로 설정
  - 함수가 종료되는 방법에 관계없이 작업 디렉토리가 그 이전 값으로 돌아가는 것을 보장하기 위해 `on.exit()`를 사용
  - 마지막으로 명시적인 코드 평가를 강제함
- 하나의 함수에서 복수의 `on.exit()` 사용을 원한다면 `add = TRUE`를 사용해야 함


## 용어 정리
- 렉시칼 스코핑(lexical scoping)
  - 함수나 변수가 <b>생성되거나 선언</b>되었을 때 해당 함수나 변수의 범위(전역, 지역 등)을 결정한다는 의미
  - 정적 스코프라고도 부름
  - 렉시칼(lexical)의 의미는 사전적 의미보단 텍스트로 표현된 코드를 프로그래밍 언어가 이해하는 의미 조각으로 변환하는 과정의 일부로서 컴퓨터 공학 용어인 <b>렉싱(lexing)</b>에서 유래한 것
- 다이나믹 스코핑(dynamic scoping)
  - 함수나 변수가 어디서 호출하였는지에 따라 상위 스코프를 결정하는 것
- 풋프린트(footprint)
  - 특정 하드웨어나 소프트웨어 단위가 차지하고 있는 공간의 크기


## 퀴즈
1. 함수의 세 가지 구성 요소
2. 다음 코드는 무엇을 반환하는가?
~~~r
x <- 10
f1 <- function(x){
    function(){
        x + 10
    }
}
f1(1)()
~~~
3. 다음 코드를 어떻게 조금 더 전형적으로 쓸 수 있는가?
~~~r 
`+`(1, `*`(2, 3))
~~~
4. 다음을 어떻게 조금 더 읽기 쉽게 만들 수 있는가? 
~~~r
mean(, TRUE, x = c(1:10, NA))
~~~
5. 다음의 함수는 호출될 때 오류를 발생시키는가? 이유는 무엇인가?
~~~r
f2 <- function(a, b){
    a * 10
}
f2(10, stop("This is an error!"))
~~~
6. 삽입 함수란 무엇인가? 어떻게 작성할 수 있는가? 대체 함수란 무엇인가? 그것을 어떻게 작성할 수 있는가? 
7. 함수가 어떻게 끝나는지에 상관없이 cleanup action이 발생할 것을 보장하기 위해 어떤 함수를 사용할 것인가? 
8. 어떤 함수가 객체의 함수 여부를 알려주는가? 어떤 함수의 원시 함수 여부를 알려 주는 함수는 무엇인가? 
9. 다음 코드는 base 패키지 내의 모든 함수 목록을 만듬
~~~r
objs <- mget(ls("package:base"), inherits = TRUE)
funs <- Filter(is.function, objs)
~~~
- a base 함수 중 어느 것이 가장 많은 인자를 가지는가?
- b base 함수 중 인자가 없는 것은 얼마나 되는가? 그러한 함수는 어떤 점이 특별한가?
- c 모든 원시 함수를 찾는데 이 코드를 어떻게 적용할 수 있는가?
10. 함수의 주요 구성요소 3가지는 무엇인가?
11. 함수를 출력할 때 생성된 환경을 보여주지 않는 경우는 언제인가?
12. 다음 코드는 무엇을 반환하는가? 그 이유는 무엇인가? 세 종류의 c가 의미하는 것은 각각 무엇인가? 
13. R이 값을 찾는 방법을 지배하는 네 가지 원칙? 
14. 다음 함수는 무엇을 반환하는가?
~~~r 
f <- function(x){
    f <- function(x){
        f <- function(){
            x ^ 2
        }
        f(x) + 1
    }
    f(x) + 2
}
f(10)
~~~
15. 다음의 특이한 함수 호출을 명확히 설명해 보라
~~~r
x <- sample(replace = T, 20, x = c(1:10 , NA))
y <- runif(min = 0, max = 1, 20)
cor(m = "k", y = y, u = "p", x = x)
~~~
16. 다음의 함수는 무엇을 반환하는가? 그 이유는 무엇인가? 이를 설명하는 원칙은 무엇인가? 
~~~r
f1 <- function(x = {y <- 1; 2}, y = 0){
    x + y
}
f1()
~~~
17. base 패키지에서 찾을 수 있는 모두 대체 함수의 목록을 생성. 어느 것이 원시 함수인가?
18. 사용자 생성 삽입 함수에 유효한 이름은 무엇인가?
19. `xor()` 삽입 연산자를 만들어 보라
20. 집합 함수인 `intersect()`, `union()`, `setdiff()`의 삽입 버전을 만들어 보라
21. 어떤 벡터의 임의의 위치를 수정하는 대체 함수를 만들어 보라
22. `source()`의 chdir 파라미터는 `in_dir()`와 어떻게 다른가? 한 접근법을 다른 것보다 선호하는 이유는 무엇인가? 
23. 어떤 함수가 `library()`의 행동을 무효화하는가? `option()`과 `par()`의 값을 저장하고 복원하는 방법은 무엇인가? 


## quiz 답안
8.어떤 함수가 객체의 함수 여부를 알려주는가? 어떤 함수의 원시 함수 여부를 알려 주는 함수는 무엇인가?  
- `is.function()`/ `is.primitive()`  

9.1 base 함수 중 어느 것이 가장 많은 인자를 가지는가?  
~~~r
tt <- unlist(lapply(funs, function(x){length(formals(x))}))
tt[order(tt, decreasing = T)][1]
~~~
9.2 base 함수 중 인자가 없는 것은 얼마나 되는가? 그러한 함수는 어떤 점이 특별한가?  
9.3 모든 원시 함수를 찾는데 이 코드를 어떻게 적용할 수 있는가?  
~~~r
tt <- unlist(lapply(funs, function(x){is.primitive(x)}))
names(tt)[tt]
~~~
10. 함수의 주요 구성요소 3가지는 무엇인가? 
- body, formals, environment
11. 함수를 출력할 때 생성된 환경을 보여주지 않는 경우는 언제인가? 
- 함수 자체 생성이 global environment에서 생성되었을 때  
12. 다음 코드는 무엇을 반환하는가? 그 이유는 무엇인가? 세 종류의 c가 의미하는 것은 각각 무엇인가? 
- variable c, parameter c, combine c(function)
13. R이 값을 찾는 방법을 지배하는 네 가지 원칙? 
  - name masking
  - functions vs variables
  - a fresh start
  - dynamic lookup
14. 다음 함수는 무엇을 반환하는가?
- 103
15. 다음의 특이한 함수 호출을 명확히 설명해 보라
16. 다음의 함수는 무엇을 반환하는가? 그 이유는 무엇인가? 이를 설명하는 원칙은 무엇인가? 
- 3
- 지연 평가(lazy evaluation)로 설명 가능  
  함수의 인자는 오로지 내부적으로 사용할때 평가됨
17. base 패키지에서 찾을 수 있는 모두 대체 함수의 목록을 생성. 어느 것이 원시 함수인가?
18. 사용자 생성 삽입 함수에 유효한 이름은 무엇인가?
- %를 제외한 어떠한 문자열 시퀀스도 가능함
19. `xor()` 삽입 연산자를 만들어 보라
~~~r
`%xor%` <- function(a, b){
  return((a || b) && !(a && b)) 
}

FALSE %xor% TRUE
~~~
20. 집합 함수인 `intersect()`, `union()`, `setdiff()`의 삽입 버전을 만들어 보라
21. 어떤 벡터의 임의의 위치를 수정하는 대체 함수를 만들어 보라
~~~r
`modify<-` <- function(x, value){
  x <- x[sample(1:length(x))]
  x
}
~~~
