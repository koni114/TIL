# chapter 18 메모리
- R의 메모리 관리에 대해서 확실히 이해하는 것은 주어진 작업에 필요한 메모리양을 예측하고,  
  보유한 메모리를 최대한 활용하는 데 도움이 됨
- 의도하지 않은 복사가 느린 코드의 주요 원인이기 때문에 더 빠른 코드 작성에도 도움이 될 수 있음
- 이 장의 목표는 개별 객체에서 함수로, 나아가 더 큰 코드 블록으로 범위를 넓혀 R에서의 메모리 관리의 기본을 이해하는데 도움을 주기 위한 것
- 이에 따라 메모리를 확보하기 위하여 `gc()`를 호출해야 하거나 for 루프가 항상 느리다는 것과 같은 일반적인 미신에 대해 알아볼 것임 
~~~r
install.packages("devtools")
devtools::install_github("hadley/lineprof")
~~~

## 18.1 객체 크기
- R에서의 메모리 사용을 이해하기 위해 `pryr::object_size`를 먼저 살펴본다
- 이 함수는 객체가 차지하는 메모리의 바이트 수를 알려 줌
~~~r
library(pryr)
object_size(1:10)
#> 88 B

object_size(mean)
#> 832 B 

object_size(mtcars)
#> 6.74kB
~~~ 
- 이 함수는 객체 내에 공유된 요소를 고려하고 env의 크기를 포함하기 때문에 내장된 `object_size()`보다 사용하기에 좋음
- `object_size()`를 사용하여 체계적으로 정수형 벡터의 크기를 탐색하면 흥미로운 일이 발생함
- 다음 코드는 길이가 0부터 50까지인 정수형 베겉의 메모리 사용을 계산하고 시각화함
- 빈 벡터의 크기가 0이고, 메모리 사용량이 길이에 비례하여 증가할 것으로 예상할 수 있음  
  하지만 이것은 사실이 아니다
~~~r
sizes <- sapply(0:50, function(n) object_size(seq_len(n)))
plot(0:50, sizes, xlab = "Length", ylab = "Size (bytes)", type = "s")
~~~
![img]()
- 이는 정수형 벡터에만 나타나는 현상이 아님
- 길이가 0인 모든 벡터는 40바이트의 메모리를 차지함
~~~r
object_size(numeric())
#> 40 B

object_size(logical())
#> 40 B

object_size(raw())
#> 40 B

object_size(list())
#> 40 B
~~~ 
- R의 모든 객체가 소유한 네 개의 구성요소를 저장하는 데 이와 같은 40바이트가 사용됨
  - 객체 메타 데이터(4바이트), 이런 메타 데이터는 베이스 타입(예를 들어 정수형) 및 디버깅과 메모리 관리에 사용되는 정보를 저장
  - 두 개의 포인터: 메모리에서 다음 객체로 하나, 이전 객체에 하나(2 * 8바이트), 이 이중 연결 리스트(doubly-linked list)는 내부 R 코드가 메모리의 모든 객체를 거쳐 반복하기 쉽게 만듬
  - 속성에 대한 포인터(8바이트)
- 모든 벡터는 세 가지 추가적 속성을 가짐
  - 벡터의 길이(4바이트), 4바이트만 사용하면 R이 최대 2^31개의 요소만 지원하는 것으로 생각할 수 있음
  - 그러나 R 3.0.0 이상에서는 실제로 벡터를 2^52 개 요소까지 가질 수 있다
  - 벡터 자체 길이(4바이트). 객체가 환경에 사용되는 해시 테이블인 경우를 제외하고는 기본적으로 사용되지 않음. 이 경우 실제 길이는 할당된 공간을 나타내며, 길이는 현재 사용되는 공간을 나타냄
  - 데이터(몇 바이트), 빈 벡터는 0바이터의 데이터를 가짐. 수치형 벡터는 모든 요소에 대해 8바이트를 차지하고, 정수형 벡터는 4바이트, 복소수형 벡터는 16바이트를 차지
- 위의 수를 더하면 36바이트가 추가된다는 것을 알 수 있음
- 나머지 4바이트는 패딩에 사용되어 각 구성 요소가 8바이트 정도에서 시작함
- 대부분의 CPU 아키텍처에서는 이런 방식으로 포인터를 정렬해야 하며, 포인터가 필요하지 않더라도 정렬되지 않은 포인터에 액세스하는 것은 느려지는 경향이 있음
- 아래는 그래프의 절편을 설명하는 것. 그런데 왜 메모리 크기가 불규칙하게 커지는가? 
- 이유를 이해하려면 R이 운영 체제에서 메모리를 요청하는 방법을 약간 알아야 함
- `malloc()`으로 메모리를 요청하는 것은 상대적으로 비용이 큰 연산
- 작은 벡터가 생성될 때마다 메모리를 요청하는 것은 상대적으로 비용이 큰 연산
- 작은 벡터가 생성될 때마다 메모리를 요청하면 R이 상당히 느려짐
- 대신 R은 큰 메모리 블록을 요구하고, 블록 자체를 관리함
- 이 블록은 작은 벡터 풀(small vector pool)이라고 불리며, 길이가 128바이트보다 작은 벡터에 사용됨
- 효율성과 단순성을 위해 작은 벡터 풀은 단지 8, 16, 32, 48, 64 또는 128바이트 길이의 벡터만 할당
- 40바이트의 오버헤드를 제거하기 위해 이전의 플롯을 조정하면 그 값이 메모리 사용이 급격하게 증가하는 지점과 잋리한다는 것을 알 수 있음
- 128바이트를 넘으면 R은 더이상 벡터를 관리하지 않음
- 결국, 큰 메모리 덩어리를 할당하는 것은 운영 체제가 매우 잘하는 부분
- 128바이트를 초과하면 R은 8바이트의 배수로 메모리를 요청. 이것은 좋은 정렬을 보장
- 객체 크기의 미묘함은 여러 객체 간의 구성 요소가 공유될 수 있다는 것. 다음 예제를 살펴보자
~~~r
x <- 1:1e6
object_size(x)
#> 4MB

y <- list(x, x, x)
object_size(y)
#> 4MB
~~~
- R은 x를 세 번 복사하지 않을 만큼은 똑똑하기 때문에 y의 크기는 3배가 아님
- 대신 기존의 x를 가리킴
- x와 y의 크기를 개별적으로 보는 것은 오해의 소지가 있음. 이것들이 얼마나 많은 공간을 차지하는지 알고 싶다면 그것들을 같은 `object_size()` 호출에 제공해야 함
~~~r
object_size(x, y)
#> 4MB
~~~ 
- 이 경우 x와 y는 y 하나와 같은 크기의 공간을 차지함
- 항상 그런 것은 아니다. 다름 사례에서 처럼 공유된 구성 요소가 없는 겨우 개별 구성 요소의 크기를 합해 총 크기를 확인할 수 있음
~~~r
x1 <- 1:1e6
y1 <- list(1:1e6, 1:1e6, 1:1e6)

object_size(x1)
#> 4MB

object_size(y1)
#> 12MB

object_size(x1, y1)
#> 16MB

object_size(x1) + object_size(y1) == object_size(x1, y1)
#> TRUE
~~~
- R에도 전역 문자열 풀(global string pool)이 있기 때문에 동일한 문제가 문자열에도 나타남
- 즉, 고유 문자열은 한 곳에만 저장되므로 문자형 벡터는 예상보다 적은 메모리를 차지함을 의미
~~~r
object_size("banana")
#> 96MB

object_size(rep("banana", 10))
#> 216MB
~~~

## 18.2 메모리 컬렉션과 가비지 컬렉션
- `object_size()`가 단일 객체의 크기를 알려 주는 한편 `pryr::mem_used()`는 메모리 내의 모든 객체의 총 크기를 알려줌
~~~r
library(pryr)
mem_used()
#> 45MB
~~~
- 이 수치는 여러 가지 이유로 운영체제에서 보고하는 메모리양과 일치하지 않음
  - R 인터프리터 자체가 아니라 R에 의해 생성된 객체만 포함
  - R과 운영 체제 모두 느슨함. 실제로 필요할 때까지 메모리를 회수하지 않는 것임  
    OS가 아직 다시 요청하지 않았기 때문에 R이 메모리를 차지하고 있을 수도 있음
  - R은 객체가 차지하는 메모리를 계산하지만, 삭제된 객체로 인해 차이가 있을 수 있음  
    이는 메모리 파편화라고 알려져 있음
- `mem_change()`는 `mem_used()`를 기반으로 코드 실행 중 메모리가 어떻게 바뀌는지 알려 줌
- 양수는 R에 의해 사용된 메모리 증가를 나타내면 음수는 감소를 나타냄
~~~r
# 1백만 개의 정수를 저장하기 위해 약 4MB가 필요
mem_change(x <- 1:1e6)
#> 4.01MB

# 그 정수들을 삭제할 때 사용된 메모리가 회수됨
mem_change(rm(x))
#> -4MB
~~~
- 아무 것도 하지 않는 연산조차도 약간의 메모리를 소비
- 이것은 R이 모든 작업의 기록을 추적하기 때문
- 따라서 몇 kB 정도는 무시할 수 있음
~~~r
mem_change(NULL)
#> 1.3kB

mem_change(NULL)
#> 1.3kB 
~~~
- 일부 언어에서는 사용하지 않는 객체를 명시적으로 삭제해야만 메모리가 반환
- R은 대안적인 접근법인 가비지 콜렉션(garbage collection : GC)을 사용
- GC는 객체가 더 이상 사용되지 않을 때 메모리를 자동으로 해제
- 얼마나 많은 이름이 각 객체를 가리키고 있는지 추적하고, 객체를 가리키는 이름이 없는 경우 해당 객체를 삭제
~~~r
mem_change(x <- 1:1e6)
#> 4MB

mem_change(y< - 1:1e6)
#> 1.36kB

# x를 제거해도 y가 여전히 그 객체를 바라보고 있으므로, 메모리가 해제되지 않음
mem_change(rm(x))
#> -4MB

# 그 객체를 지시하고 있는 것이 아무것도 없게 되면 메모리가 해제됨
mem_change(rm(y))
#> -4MB
~~~
- 다른 곳에서 읽어 봤을 수 있지만, 사용자가 직접 `gc()`를 호출 할 필요가 없음
- R은 더 많은 공간을 필요로 할 때 마다 자동으로 가비지 콜렉션을 실행
- 그것이 언제 나타나는지 보고 싶다면 `gcinfo(TRUE)`를 호출해라
- `gc()`를 호출하고자 하는 유일한 이뉴는 운영체제에 메모리를 반환하도록 R에게 요청하는 것
- 그러나 그것조차 아무런 영향이 없을 수 있음. 오래된 버전의 Windows에서는 프로그램이 OS로 반환할 방법이 없기 때문
- GC는 더 이상 사용하지 않는 객체를 해제하는 것을 다루는 것
- 그러나 발생 가능한 메모리 누수에 대해 알고 있어야 함
- 객체를 해제하지 않고 계속 가리키면 메모리 누수가 발생함
- R에서 포뮬라와 클로저가 엔클로징 환경을 캡처하기 때문에 메모리 누수의 두 가지 주된 원인이 됨
- 다음 코드는 이 문제를 설명함
- `f1()`에서 1:1e6은 오로지 함수 내에서만 참조되므로 함수가 완료되면 메모리가 반환되고 순변화는 0임
- `f2()` 와  `f3()`는 둘 다 환경을 캡처하는 객체를 반환하므로 함수가 완료될 때까지 x가 해제되지 않음
~~~r
f1 <- function(){
    x <- 1:1e6
    10
}
mem_change(x <- f1())
#> 1.26kB

object_size(x)
#> 48B

f2 <- function(){
    x <- 1:1e6
    a ~ b
}
mem_change(y <- f2())
#> 4MB

object_size(y)
#> 4MB

f3 <- function(){
    x <- 1:1e6
    function() 10
}
mem_change(z <- f3())
#> 4MB

object_size(z)
#> 4.01MB
~~~

## 18.3 lineprof를 이용한 메모리 프로파일링
- `mem_change()`는 코드 블록을 실행할 때 메모리의 순변화를 캡처
- 그러나 때로는 점증적인 변화를 측정하기를 원할 수도 있음
- 이를 수행하는 한가지 방법은 메모리 프로파일링을 사용하여 몇 밀리초마다 사용량을 캡처하는 것
- `lineprof` 패키지를 사용할 것임. 이것은 `Rprof()`에 의해 구동되지만 보다 유익한 방식으로 결과를 표시
- lineof를 시연하기 위해 세 개의 인자만 가진 `read.delim()` 의 핵심적 구현을 살펴볼 것
~~~r
read_delim <- function(file, header = TRUE, sep = ","){
    # 첫 번째 줄을 읽으면서 필드의 수를 판단
    first <- scan(file, what = character(1), nlines = 1, sep = sep, quite = TRUE)
    p <- length(first)

    # 모든 필드를 문자형 벡터로 로드
    all <- scan(file, what = as.list(rep("character", p)), 
    sep = sep, skip = if (header) 1 else 0, quite = TRUE)

    # 문자열에서 적절한 타입으로 변형(펙터형으로는 하지 말 것)
    all[] <- lapply(all, type.convert, as.is = TRUE)

    # 열 이름 설정
    if (header) {
        names(all) <- first
    } else {
        names(all) <- paste0("V", seq_along(all))
    }

    # 리스트를 데이터 프레임으로 변형
    as.data.frame(all)
}
~~~
- 샘플로 사용할 csv 파일도 생성할 것임
~~~r
library(ggplot2)
write.csv(diamonds, "diamonds.csv", row.names = FALSE)
~~~
- lineprof를 사용하는 것은 간단. `source()`로 코드를 로드하고, `lineprof()`을 표현식에 적용한 다음, `shine()`을 사용하여 결과를 확인
- 코드를 로드하려면 반드시 그 코드를 `source()`로 로드해야 함
- 이것은 lineprof가 srcrefs를 사용하여 코드와 실행 시간을 매칭하기 때문임
- 필요한 srcrefs 디스크에서 코드를 로드할 때만 생성
~~~r
library(lineprof)
source("code/read-delim.R")
prof <- lineprof(read_delim("diamonds.csv"))
shine(prof)
~~~
- t : 해당 코드 행에 소비된 시간
- a: 해당 코드 행에 의해 할당된 메모리
- r: 해당 코드 행에 의해 해제된 메모리. 메모리 할당은 결정적이지만 메모리 방출은 확률적인데, 그 차이는 GC 실행 시기에 달려있음
- d: 발생한 벡터 중복 횟수
-  
