# chapter02 컨테이너의 이해
- 최근 개발시에는 다양한 라이브러리나 오픈 소스 기반 프레임워크를 활용하여 개발하는 추세
- 이는 개발 생산성이 좋아지는 대신에 애플리케이션 S/W의 안정성을 유지하기 어려워짐
- docker는 이러한 문제를 컨테이너를 통해 해결함
- 컨테이너를 운영하는 플랫폼 쿠버네티스도 일부 묘듈이 컨테이너로 되어 있음

## 컨테이너를 사용하는 이유
### 인프라의 사용률 향상
- 하나의 물리 서버나 가상 서버 위에서 여러 개의 컨테이너를 돌릴 수 있음

### 빠른 기동 시간
- 컨테이너의 기동 시간은 가상 서버, 물리 서버의 기동시간보다 훨씬 빠름
- 운영체제, 애플리케이션, 미들웨어 등 다양한 이미지를 쉽게 가져올 수 있음
- 설치 작업이나 설정 작업이 줄어듬
- 네트워크, 볼륨(외부 저장)을 S/W 정의 오브젝트로 작성할 수 있음

### 불변 실행 환경
- 애플리케이션 실행에 필요한 소프트웨어를 모두 포함하여 컨테이너 작성 가능
- 특정 서버 환경에 대한 종속성을 배제할 수 있음
- 개발 환경과 운영 환경의 차이를 줄일 수 있음

## 가상 서버와 컨테이너의 차이점
### 가상 서버
- <b>가상 서버는 가상화 소프트웨어를 사용하여 하드웨어를 공유하는 형태</b>로, 마치 한 대의 전용 서버가 있는 것처럼 이용할 수 있게 해줌
- 한 대의 머신에서도 여러 대의 가상 서버를 기동할 수 있음
- 가상화 소프트웨어를 하이퍼바이저라 부르며, VMware, Xen, KVM, virtualbox, Hyper-V와 같이 상용 제품부터 오픈 소스까지 다양한 제품이 있음

### 컨테이너
- 컨테이너는 하나의 리눅스 프로세스가 마치 전용 서버에서 동작하고 있는 것 같은 분리 상태를 만들어냄
- 리눅스 커널의 네임스페이스와 컨트롤 그룹(control group)이라는 기술을 기반으로 함

![img](https://github.com/koni114/TIL/blob/master/container/docker/img/docker_02.png)

### 컨테이너와 가상 서버 비교
| 특징  | 가상 서버 | 컨테이너 |
| --- | --- | --- |
| 이미지크기(CentOS 7.4의 경우) | 최소 1.54GB | 최소 0.20GB |
| 메모리 사용량 | 기본 640MB | 기본 512MB |
| 벤치 마크 성능 비교 | 65%(Xen HVM 가상 서버) | 90% |
| OS 기동 시간 | 분 단위 | 초 단위 |

- window 나 Mac에서 돌리려면 리눅스 커널을 위해 가상 서버 필요
- Docker CE를 Mac이나 window에 설치하면 각각의 하이퍼바이저 위에서 Linuxkit이 기동되고, 그 위에 컨테이너의 런타임인 `containered`가 기동함
- Linuxkit은 컨테이너를 실행하기 위한 경량의 리눅스 서브 시스템
- 컨테이너는 하이퍼바이저 가상 서버에서도 사용할 수 있음. 퍼블릭 클라우드의 가상 서버나 온프레미스의 Openstack 위에서 활용됨 

![img](https://github.com/koni114/TIL/blob/master/container/docker/img/docker_03.png)

## docker의 아키텍처
- 도커는 소프트웨어 개발자가 컨테이너를 이용해 개발 생산성을 높일 수 있도록 컨테이너를 build(작성), ship(이동), run(실행) 할 수 있는 기능을 지원
- 도커는 <b>도커 데몬 서버, 클라이언트인 도커 커맨드, 이미지의 보관소인 레지스트리로 구성</b>

![img](https://github.com/koni114/TIL/blob/master/container/docker/img/docker_04.png)

### 도커 데몬
- 클라이언트인 도커 커맨드의 명령을 받아드려 도커 오브젝트인 이미지, 컨테이너, 볼륨, 이미지 등을 관리
- 도커 데몬은 네트워크 너머에 있는 원격 클라이언트로부터 요청을 받는 것도 가능

### 도커 클라이언트
- 도커 커맨드는 컨테이너를 조작하는 커맨드 라인 유저 인터페이스로 도커 데몬의 클라이언트임
- 도커 커맨드는 도커 API를 사용하여 도커 데몬에 요청을 보냄
- 자주 사용하는 명령어
  - `docker build` : 새로운 이미지 작성 
  - `docker pull` : 레지스트리에서 이미지를 로컬에 다운로드 받을 때 사용
  - `docker run` : 이미지를 바탕으로 컨테이너 실행

### 이미지
- 이미지는 읽기 전용인 컨테이너의 탬플릿을 말함
- 컨테이너를 기동하기 위한 실행 파일과 설정 파일의 묶음
- 도커 허브에는 데이터베이스, 웹 서버, 애플리케이션 등 다양한 이미지가 등록되어 있음
- 예를 들어 CI/CD 도구인 젠킨스(Jenkins)도 도커 허브에 등록되어 있어 이미지를 다운로드 받으면 특별한 설치없이 젠킨스 서버 기동가능
- 대부분의 이미지는 다른 이미지에 기반하여 만들어짐

### Nginx 이미지 만들기
![img](https://github.com/koni114/TIL/blob/master/container/docker/img/docker_05.png)

- 이미지를 만들 때는 기반 이미지와 설치 스크립트 등을 Dockerfile에 기재해서 빌드
- ① `docker build` 명령어를 통해 dockerfile이 읽혀짐
- ② 기반이 되는 데비안 이미지가 로컬에 없으면 레지스트리로부터 다운받음
- ③ 데비안 이미지를 컨테이너로 기동
- ④ Nginx 패키지를 설치하고 설정 파일 추가
- ⑤ 새로운 이미지 Nginx 로 로컬 레포에 저장

### 컨테이너
- 컨테이너는 하나의 프로세스라고 볼 수 있음
- 리눅스의 네임스페이스나 컨트롤 그룹(Cgroup)을 통해 다른 프로세스들과 완전히 분리되어 실행되는 프로세스
- 컨테이너는 정지된 상태로도 관리되기 때문에 <b>실행 가능한 이미지의 인스턴스</b>라고 할 수 있음
- `docker run` 명령어를 통해 이미지는 컨테이너로 변환되어 하나의 인스턴스가 됨
- 실행 상태의 컨테이너는 IP 주소를 가지는 하나의 독립된 서버로 동작함
- `docker kill`, `docker stop` --> 컨테이너 정지. 삭제되는 것은 아님
- 삭제하기 위해서는 `docker rm` 명령어 수행
- `docker start`를 통해 docker 컨테이너 기동. <b>주의할 점은 정지 전에 할당되었던 IP 주소가 유지되지 않음</b>

### 도커 레지스트리
- 도커 레지스트리는 컨테이너의 이미지가 보관되는 곳
- `docker run hello-world` --> 공개 레지스트리의 도커 허브에 등록된 이미지 hello world를 다운받아 컨테이너로서 실행
- 레지스트리는 리포지터리를 여러개 가지는 보관 서비스. 리포지터리는 하나의 이미지에 대해 태그를 사용하여 다양한 출시 버전을 함께 보관하는 곳
  - 퍼블릭 레지스트리
  - 클라우드 레지스트리
  - 비공개 레지스트리

## 레지스트리와 쿠버네티스의 관계
- 쿠버네티스에서도 레지스트리에서 이미지를 다운로드 받아 컨테이너를 실행
- 레지스트리는 쿠버네티스를 사용할 때 반드시 필요한 서비스

![img](https://github.com/koni114/TIL/blob/master/container/docker/img/docker_06.png)

- ① `docker build` 로 이미지 빌드
- ② `docker push`로 이미지를 레지스트리에 등록
- ③ kubectl 커맨드로 매니페스트에 기재한 오브젝트들의 생성을 요청
- ④ 매니페스트에 기재된 리포지터리로부터 컨테이너의 이미지를 다운로드함
- ⑤ 컨테이너를 파드 위에서 기동

## 도커와 쿠버네티스의 연동
- 쿠버네티스는 도커를 컨테이너의 런타임 환경으로 사용. 즉 쿠버네티스를 설치할 때 제일 먼저 도커를 설치해야 함

### 도커와 쿠버네티스 연동 프로세스
![img](https://github.com/koni114/TIL/blob/master/container/docker/img/docker_07.png)

- 도커 데몬 프로세스인 `dockerd` 와 연동하여 동작하는 `containerd` 는 다양한 플랫폼 위에서 동작하는 업계 표준 코어 컨테이너 런타임으로 간결하고 높은 이식성을 목표로 개발
- 이를 통해 이미지 보관 및 전송, 컨테이너 실행, 볼륨과 네트워크 연결과 같은 컨테이너의 라이프 사이클을 호스트에서 완전히 관리할 수 있게 됨
- containerd는 OCI(Open Container Initiative) 의 표준 사양에 준하는 컨테이너 런타임 runC를 사용
- CRI를 통해 컨테이너 실행 요청을 받으면 `containerd` 는 `containerd-shim` 을 만듬
- `runC`는 컨테이너를 띄운 후 바로 종료하며, 이어서 container-shim이 프로세스로 남게 됨
- 내부 표준화가 진행됨에 따라 향후 쿠버네티스의 컨테이너 실행 환경은 도커 설치를 필수로 하지 않게 되어, 심플하고 경량으로 고속화될 수 있는 방향으로 개발이 진행되고 있음
- public cloud의 쿠버네티스 관리 서비스와 상용 제품에서도 containerd와 kubelet이 직접 연계하는 방향으로 진행되고 있음 

## 컨테이너를 위한 기술과 표준
### 리눅스 표준 규격과 리눅스 ABI
- 도커를 사용하면 다양한 리눅스 배포판을 기반으로 한 컨테이너 실행이 가능
- 리눅스 배포판과 커널 버전이 달라도 동작하는 이유
  - LBS(Linux Base Standard)는 소스 코드를 컴파일한 시점에서 호환성 있는 머신 코드를 생성하도록 ISO 규격으로 표준화되어 있음
  - 리눅스 ABI(Application Binary Interface)로 인해 리눅스 커널의 버전이 올라가도 유저 공간에서 동작하는 바이너리 레벨의 호환성은 유지

### 리눅스 커널 기술 
#### 네임스페이스(namespace)
- 네임스페이스는 리눅스 커널에 사용된 기술로 컨테이너가 하나의 독립된 서버와 같이 동작할 수 있게함
- 네임스페이스 사용시 특정 프로세스를 다른 프로세스로부터 분리시켜 같은 네임스페이스 내에서만 접근할 수 있도록 제한 가능

#### 컨트롤 그룹(control group)
- 도커는 리눅스 커널의 cgroup을 사용하는데, 이는 프로세스별로 CPU 시간이나 메모리 사용량과 같은 자원을 감시하고 제한함

#### 유니온 파일 시스템(UnionFS)
- 다른 파일 시스템에서 파일이나 디렉터리를 투과적으로 겹쳐서, 하나의 일관적인 파일 시스템으로 사용할 수 있게 함

#### OCI(Open Container Initiative)
- 컨테이너 표준 사양을 책정하기 위해 만들어진 단체


## 용어 정리
- Linux namespace
- Linux Cgroups