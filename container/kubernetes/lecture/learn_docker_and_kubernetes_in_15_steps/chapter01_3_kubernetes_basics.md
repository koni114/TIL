# chapter03 쿠버네티스의 기본
## 아키텍처
![img](https://github.com/koni114/TIL/blob/master/container/docker/img/docker_15.png)

- 다음은 쿠버네티스 업스트림의 기본 구성. 퍼블릭 클라우드의 쿠버네티스 관리 서비스에는 이외에 추가적인 컴포넌트들이 있지만, 업스트림의 핵심 기능이 가장 중점이 됨
- 다음은 멀티 노드 K8s에서 마스터를 포함한 모든 노드에서 동작하는 파드의 목록을 출력한 결과
~~~shell
$ kubectl get pods --all-namespaces --sort-by=.spec.nodeName -o=custom-columns=NODE:.spec.nodeName,NAME:.metadata.name,IMAGE:.spec.containers[0].image
~~~
![img](https://github.com/koni114/TIL/blob/master/container/docker/img/docker_10.png)

- `NODE`: 각 노드의 역할을 의미 제어를 담당하는 master와 실행을 담당하는 node1, node2가 존재
- `NAME`: 컨테이너의 실행 단위인 파드의 이름. 네임스페이스(Namespace) 내에서 유일한 이름이 되도록 해시 문자열이 추가로 붙기도 함
- `IMAGE`: 컨테이너의 이미지와 태그
- 앞의 파드의 목록들은 업스트림 쿠버네티스에서 실행한 결과임. 퍼블릭 클라우드의 쿠버네티스 관리 서비스에서 실행해 보면 마스터에서 돌아가는 파드는 표시되지 않고, 각 업체가 독자적으로 추가한 파드도 있어 다소 다른 결과를 확인할 수 있지만, 코어는 동일
- 미니쿠베(minikube)에서 실행하는 경우, 하나의 가상 서버에서 동작하고 있기 때문에 노드가 전부 동일
- 또한 위에서 표시되는 것은 '파드'라 불리는 컨테이너에서 실행되는 것이기 때문에 리눅스 프로세스로 동작하는 부분은 포함되지 않음

### 쿠버네티스를 구성하는 기본 컴포넌트와 플러그인
| 구성요소 | 개요 |
| --- | --- |
| kubectl | k8s 클러스터를 조작하기 위한 도구로 가장 빈번하게 이용되는 커맨드 라인 인터페이스 |
| kube-apiserver | kubectl 등의 API 클라이언트로부터 오는 REST 요청을 검증하고, API 오브젝트를 구성하고 상태를 보고함 |
| kube-scheduler | 쿠버네티스의 기본 스케줄러, 새로 생성된 모든 파드에 대해 실행할 최적의 노드를 선택<br>스케줄러는 파드가 실행 가능한 노드를 찾은 다음 점수를 계산하여 가장 점수가 높은 노드를 선택 |
| kube-controller-manager | 컨트롤러를 구동하는 마스터상의 컴포넌트 |
| cloud--controller-manager | API를 통해서 클라우드 서비스와 연계하는 컨트롤러로, 클라우드 업체에서 개발 |
| etcd | K8s 클러스터의 모든 관리 데이터는 etcd에 저장됨. 이 etcd는 CoreOS가 개발한 분산 키/값 저장소로 신뢰성이 요구되는 핵심 데이터의 저장 및 접근을 위해 설계됨 |
| kubelet | kubelet는 각 노드에서 다음과 같은 역할 수행<br>\- 파드의 컨테이너 실행<br>\- 파드와 노드의 상태를 API 서버에 보고<br>\- 컨테이너의 동작을 확인하는 프로브 실행<br>\- 내장된 cAdvisor를 통해 매트릭 수집 및 공개 |
| kube-floxy | kube-floxy는 각 노드에서 동작하며 로드밸런싱 기능 제공<br>\- 서비스와 파드의 변경을 감지하여 최신 상태로 유지<br>\- iptables 규칙을 관리<br>\- 서비스명과 ClusterIP를 내부 DNS에 등록 |
| coredns | 파드가 서비스 이름으로부터 IP 주소를 얻기 위해 사용됨.<br>버전 1.11부터, kube-dns 대신 coredns가 사용. <br>이전의 kube-dns가 부족했던 신뢰성, 보안성, 유연성이 coredns에서 개선됨<br>CoreDNS 프로젝트는 CNCF가 관리 |

### 애드온 컴포넌트
| 구성요소 | 개요  |
| --- | --- |
| kube-flannel | 모든 노드에서 실행되어 여러 노드 사이의 IPv4 네트워크를 제공<br>이에 따라 컨테이너(파드)는 K8s 클러스터 내부에서 사용되는 IP 주소를 바탕으로 다른 노드에 있는 파드와 통신 가능 |
| calico-kube-controllers | calico를 위한 컨트롤러, 데이터 스토어로서 etcd를 이용하기 위해 사용 |
| calico-node | 모든 노드에서 실행되어 노드 간 파드의 통신, 라우팅, 네트워크 접근 관리 기능을 제공 |
| kubernetes-dashboard | Web 대시보드 |
| metric-server | K8s 클러스터 전체로부터 매트릭을 수집 |

## 쿠버네티스 계층 구조
![img](https://github.com/koni114/TIL/blob/master/container/docker/img/docker_16.png)

- 마스터 노드의 역할
  - 쿠버네티스의 API 서버로서 클라이언트로부터의 명령을 받아드리고 실행
  - 컨테이너를 파드 단위로 스케줄링 및 삭제
  - 파드의 컨트롤러 기능과 외부 리소스 관리
- 쿠버네티스에서의 스케줄링은 파드를 실행할 노드를 정하는 것을 말함
- 마스터는 각 노드의 CPU, 메모리 예약 상황, 그리고 실제 사용량을 감시하고 있음
- 새로운 파드를 배치해야 할 때는 해당 파드의 매니페스트에 기재된 CPU와 메모리 요청값 및 상한값을 기준으로 조건에 부합하는 노드를 찾아 파드를 스케줄. 즉 파드의 실행 할당

## 쿠버네티스 API 오브젝트
### 쿠버네티스 API란
- 쿠버네티스의 조작은 모두 API를 통해 이루어짐. 
- 커맨드 라인 유저 인터페이스인 kubectl은 마스터 노드상의 kube-apiserver에게 쿠버네티스 API 규약에 맞게 기술된 목표 상태 선언서인 매니페스트를 YAML 형식 혹은 JSON 형식으로 전송하여 오브젝트를 만들고, 바꾸고, 제거하는 일을 함
- 파이썬, GO 등 다양한 프로그램 언어로 API 라이브러리가 제공됨. 예를 들어 파이썬, Go 언어를 사용하여 쿠버네티스 운영을 자동화하는 것이 가능

### 오브젝트란
- K8s 클러스터 내부의 엔티티로서, 이후 설명할 파드, 컨트롤러, 서비스 등의 인스턴스를 말함
- 오브젝트는 지정된 상태가 유지되도록 쿠버네티스에 의해 제어됨
- 각 오브젝트는 메타 데이터에 기술된 이름에 의해 식별됨. 따라서 오브젝트를 만들 때는 반드시 이름을 부여해야 함
- 같은 종류의 오브젝트의 이름은 하나의 네임스페이스 내에 유일해야 함
- <b>네임스페이스는 논리적으로 K8s 클러스터를 분할하여 사용하기 위해 존재하는 기능</b>

### 워크로드(Workload)
- 오브젝트의 카테고리를 나타내는 용어로 컨테이너와 파드, 그리고 컨트롤러의 그룹을 의미. 이들은 컨테이너의 실행을 관리하기 위해 사용됨
- 기존 워크로드의 의미는 애플리케이션이나 프로그램의 부하를 말하는데, 쿠버네티스에서는 다른 의미로 사용되므로 주의

### 컨테이너(Container)
- <b>쿠버네티스에서는 컨테이너를 독자적으로 실행하는 것은 불가능하며, 반드시 파드 내에서 실행해야 함</b>
- 컨테이너 기동시 실행할 수 있는 항목은 이미지의 이름, 실행 명령어, 실행 인자, 환경 변수, 볼륨, CPU 사용 시간과 메모리 크기의 요청 및 상한값

### 파드(Pod)
- 파드는 컨테이너를 실행하기 위한 오브젝트이며, 여러 개의 컨테이너를 담을 수 있음

### 컨트롤러(Controller)
- 파드의 실행을 제어하는 오브젝트
- 여러 종류의 컨트롤러가 있어 컨트롤러 별로 기능을 이해하고 적재 적소에 활용해야 함
- <b>디플로이먼트 컨트롤러</b>는 클라이언트-서버 구조에 적합하며, 서버에 돌아가는 파드의 개수가 지정한 숫자보다 적으면 자동으로 지정한 개수가 되도록 파드를 기동시킴
- <b>잡 컨트롤러</b>는 배치 처리가 정상 종료 될 때까지 재실행을 반복

### 설정(Configuration)
- 컨테이너 내 애플리케이션의 설정값이나 비밀번호 등의 정보는 배포된 네임스페이스로부터 취득하는 것이 좋음
- 이를 위해 설정을 저장할 수 있는 ConfigMap과 비밀번호와 같은 기밀 정보를 담기 위한 시크릿(Secret)이라는 오브젝트가 있음
- 이들을 통해 네임스페이스에 저장된 정보는 컨테이너 내의 파일이나 환경 변수를 통해 애플리케이션에서 참조할 수 있음

### 서비스(Service)
- 파드와 클라이언트를 연결하는 역할을 수행
- 서버의 역할을 수행하는 pod가 클라이언트의 요청을 수행할 수 있도록 대표 IP 주소를 취득하여 내부 DNS에 등록

### 스토리지(Storage)
- 복수의 노드에서 접속 가능한 PV는 쿠버네티스의 범위에 포함되지 않기 때문에 외부 스토리지를 연동해야 함
- 외부 스토리지 시스템의 프로토콜과 API의 차이점을 은폐하기 위하여 쿠버네티스는 계층적으로 추상화한 오브젝트를 제공

## 파드의 기본
- 파드에 속한 모든 컨테이너는 같은 노드에서 동작

### 컨테이너 재사용 촉진을 위한 플랫폼
- 파드는 하나의 목적을 위해서 만들어진 여러 개의 컨테이너를 부품처럼 조합할 수 있도록 설계됨
- '1. 파드의 내부 컨테이너들은 파드의 IP와 port번호를 공유할 수 있음
- '2. 파드의 내부 컨테이너들은 localhost로 서로 통신할 수 있음
- '3. 내부 컨테이너들은 System V 프로세스 통신이나 POSIX 공유 메모리를 사용하여 서로 통신할 수 있음
- '4. 파드의 내부 컨테이너들은 파드의 볼륨을 마운트하여 파일 시스템을 공유 가능
- 위의 1~4번 기능들은 파드 내의 컨테이너 사이에서만 가능하며, 다른 파드에 있는 컨테이너들은 불가능

### 파드는 일시적인 존재
- 파드는 일시적인 존재로 설계되어 파드 내의 컨테이너는 이미지로부터 매번 생성됨
- 같은 오브젝트 이름으로 몇 번이고 파드를 기동해도 이전에 컨테이너에서 수행한 변경 이력은 남지 않고, 이미지의 초기 상태에서 시작할 뿐임
- 파드의 IP 주소도 고정적이지 않으며, 파드는 컨트롤러에 의해서 동적으로 생성되고 종료되므로, 언제 IP 주소가 바뀔지 모름
- 따라서 <b>파드에 요청을 보내고 싶은 경우, 반드시 서비스를 이용해야함</b>

### 파드는 컨테이너의 실행 상태를 관리
- 파드가 정지한 경우는 컨트롤러가 재기동 등의 처리를 수행하고, 컨테이너가 정지한 경우에는 파드가 해당 컨테이너를 재시작함
- 설정에 따라서는 정지한 컨테이너를 그대로 유지한 채 로그를 참조할 수 있도록 하는 것도 가능
- 파드는 <b>활성 프로브(Liveness probe)</b>와 <b>준비 상태 프로브(Readliness Probe)</b>를 설정하여 내부 애플리케이션의 상태를 감시할 수 있음
- 활성 프로브를 설정하면 애플리케이션이 멈춰 있는 상태를 감지하여 컨테이너를 강제 종료 시킬 수 있음
- 준비 상태 프로브를 설정하면, 파드가 요청을 받을 준비가 될 때까지 서비스 오브젝트가 요청을 전송하지 않음 

### 파드는 초기화 전용 컨테이너를 실행
- 파드에 초기화만을 담당하는 컨테이너를 설정할 수 있음
- 파드가 기동된 후 초기화 담당 컨테이너가 제일 먼저 실행되며 초기화가 끝나면 핵심 기능을 수행하는 컨테이너들이 실행됨
- 파드는 IP 주소를 가지고, 복수의 컨테이너를 내포하고, 하나의 가상 서버처럼 동작하지만 기존의 서버를 관리하는 것처럼 호스트 이름을 붙여 오랫동안 정성들여 관리를 하는 것과는 다른 방식으로 설계 됨

## 파드의 라이프 사이클
- 쿠버네티스의 트러블 슈팅 중 가장 많이 발생하는 것이 파드의 기동 실패 원인 분석임
- 개인의 개발 환경에서 컨테이너 이미지를 빌드하고 쿠버네티스 환경에 배포하였을 때 제일 먼저 경험하는 것이 컨테이너가 기동하지 않거나 재시작을 반복하는 현상
- 파드의 상태가 가지는 의미를 이해하고 적절한 대처를 할 수 있어야 문제를 해결할 수 있음
- 문제를 파악하기 위해서는 `kubectl get pods`를 실행했을 때 나타나는 `STATUS` 열의 정보가 중요  
  이 필드의 정보는 kubernetes API를 통해 획득하며, 이 API를 통해서 얻을 수 있는 다양한 정보 중에서 도움이 될만한 정보가 선별되어 STATUS 열에 표시됨

### kubectl get pod로 표시되는 STATUS와 의미
| STATUS | 의미와 대책 |
| --- | --- |
| ContainerCreating | 이미지를 다운로드 중이거나 컨테이너를 생성하는 중에 있음을 의미<br>configMap과 secret이 마운트되지 않아 컨테이너 생성이 보류된 경우일 수도 있음 |
| CrashLoopBackOff | 파드 내에 컨테이너가 종료되어다음 기동 시까지 대기 상태에 있음을 의미<br>2회 이상 컨테이너가 종료되면, CrashLoopBackOff 시간 동안 대기하게 됨<br>이 상황에서는  컨테이너 내의 프로세스를 재검토 할 필요가 있음 |
| Pending | 파드 생성 요구를 받았지만 하나 이상의 컨테이너가 생성되지 않은 상태를 말함<br>리소스 부족의 이유로 스케줄이 되지 않은 경우에 해당 |
| Running | 파드의 모든 컨테이너가 생성되어 실행 중임을 의미 |
| Terminating | 컨테이너의 종료 요청 시그널을 보낸 후 컨테이너가 종료할 때까지 대기 중임을 의미<br>유예 시간을 넘겨도 컨테이너가 종료할 수 없는 경우는, 컨테이너를 강제 종료함 |
| Succeeded | 파드 내 모든 컨테이너가 정상적으로 종료했음을 의미 |
| Completed | 파드 내 컨테이너가 정상적으로 종료되었음을 의미<br>파드 내에 복수의 컨테이너가 있는 경우, 첫 번째 컨테이너가 정상 종료하면 Completed가 표시 |
| Error | 컨테이너가 이상 종료된 경우<br>Exit 코드가 0이 아닌 경우에 이상 종료로 간주. 파드 내에 복수의 컨테이너가 있는 경우 첫 번째 컨테이너가 이상 종료하면, Error로 표시 |
| Failed | 파드 내에 적어도 하나의 컨테이너가 이상 종료했음을 의미 |
| Unknown | 파드의 상태를 얻을 수 없는 상황을 의미 |

## 파드의 종료 처리
- 쿠버네티스는 종료 요청 시그널을 받은 컨테이너의 애플리케이션이 일정 시간 내에 종료 처리를 완료하고 정상 종료를 하도록 요구하고 있음
- 쿠버네티스는 롤아웃이라는 기능이 있는데, 이는 운영 중인 애플리케이션을 가동 중에 업데이트 하는 기능  
  이 기능을 담당하는 컨트롤러는 가동 중인 애플리케이션에 종료 요청 시그널을 보내고 유예 시간까지 파드의 종료를 기다림
- 애플리케이션이 동작 중에 강제로 종료되면, 데이터 분실 등의 장애로 이어질 수 있음
- 애플리케이션이 동작 중에 강제로 종료되면, 데이터 분실 등의 장애로 이어질 수 있음. 따라서 애플리케이션은 유예 시간 내에 메모리상의 데이터를 PV에 보존하거나 데이터베이스와의 세션을 종료하는 등의 종료 처리를 수행해야 함
- 이러한 요청에 구현이 되어 있지 않다면, 애플리케이션은 문제를 일으킬 소지가 있음
- 파드가 삭제 요청을 받으면 컨테이너의 메인 프로세스에게 종료 요청 시그널(SIGTERM)을 보냄
  만약 컨테이너에 종료 요청 시그널에 대한 처리가 구현되지 않은 경우에는 유예 시간 동안 기다린 뒤 강제 종료됨

### 종료 처리의 흐름
- '1. 사용자가 `kubectl delete pod`를 실행하면 파드의 종료 처리가 시작됨. 기본 유예 기간은 30초
- '2. `kubectl get pod`의 `Terminating` 이라고 표시됨
- '3. 다음 세 가지 작업이 동시에 진행됨
  - 파드의 `PreStop hook`이 정의되어 있으면, 파드 내에서 호출됨. 유예시간을 넘어서면 PreStop hook이 실행되고 있어도, 파드 내의 메인 프로세스에 SIGTERM이 보내지며, 2초 후에 SIGSKILL로 강제 종료됨
  - PreStop hook이 정의되어 있지 않으면, 곧바로 파드 내의 메인 프로세스에 SIGTERM 신호가 송신되며 종료 처리가 개시됨
  - 파드가 서비스이 앤드포인트 목록에서 제거되며, 로드벨런서(kube-proxy)의 목록에서도 제거됨
- '4. 유예 시간을 넘어서서 파드 내의 프로세스가 살아 있다면, 파드의 메인 프로세스에 SIGKILL을 보내 강제 종료함
- '5. 제거 대상인 파드가 표시되지 않게 함 
- `PreStop`은 컨테이너가 종료되기 직전에 호출됨. 이것은 컨테이너 내의 프로세스가 종료 요청 시그널을 받을 수 없는 제약이 있는 경우에 종료 요청을 받는 수단이 됨
- `kubectl delete`를 실행할 때 옵션 `--grace-period=초`를 통해 유예 시간을 별도로 지정할 수 있음  
  0을 설정하면 파드가 즉시 삭제 됨

## 클러스터 네트워크
- 클러스터 네트워크(=파드 네트워크)는 K8s 클러스터 내부에서 사용되는 네트워크
- 파드는 클러스터 네트워크 상의 IP 주소를 부여받아 다른 노드에 있는 파드와 서로 통신함
- 서비스의 IP 주소나 포트번호를 K8s 클러스터 외부 네트워크에서 접근할 수 있게 하려면, 서비스 타입으  NodePort 또는 LoadBalancer로 설정하거나 인그레스를 함께 사용하면 됨
- CNCF 문서를 보면 클러스터 네트워크와 파드 네트워크가 혼동되서 사용하고 있음
- 파드 네트워크의 대표적인 오픈 소스 네트워크 애드온을 소개

### Flannel
- 간단한 L3 네트워크를 노드 간에 구축함. 각 노드 위에 서브넷을 구성해서 한 노드 위의 파드가 다른 로드 위의 파드와 통신할 수 이도록 함
- Flannel의 파드는 데몬셋 컨트롤러에 의해 배포됨  
  그래서 K8s 클러스터에 새로운 노드가 추가되면 자동적으로 파드 네트워크가 확장됨
- Flannel은 네트워킹 기능만을 갖추고 있으며, 접근 제어 기능은 제공하지 않음  

### Cailco
- 노드 간 파드 통신에 더해 네트워크 접근 제어 기능을 제공
- 예를 들어, 2개의 네임스페이스 간에 통신을 금지하는 접근 제어 기능을 설정할 수 있음  

## 서비스의 기본
- 쿠버네티스의 서비스는 클라이언트의 요청을 파드에 전달하는 역할을 담당
- 이러한 서비스가 필요한 이유는 파드의 IP 주소가 기동할 때마다 바뀌기 때문. 그래서 파드에 접속해야하는 클라이언트는 서비스가 가지는 대표 IP를 사용해서 접속해야 함

![img](https://github.com/koni114/TIL/blob/master/container/docker/img/docker_17.png)

- '1. 서비스는 로드벨런서의 역할을 가지며, 클라이언트의 요청을 받기 위한 대표 IP 주소를 획득
- '2. 서비스의 이름은 내부 DNS에 등록되기 때문에 클라이언트는 서비스의 이름만으로 서비스의 IP 주소를 획득할 수 있음
- '3. 서비스는 실렉터에 지정된 라벨과 일치하는 파드 중 하나에게 요청을 전달함
- '4. 서비스가 만들어지고 나서 기동된 파드의 컨테이너에는 서비스에 대한 정보가 담긴 환경변수가 자동으로 설정됨  
- '5. 서비스에는 네 종류의 서비스 타입이 있어, 클라이언트의 범위를K8s 클러스터 내부로 한정할지, 외부까지 확장할지, 또한 K8s 클러스터 외부의 IP 주소에 전송할지를 설정
- 파드는 기동될 때 라벨이나 IP 주소를 포함한 자신의 오브젝트 정보를 마스터 노드의 etcd에 등록
- 그래서 서비스의 전송처를 결정할 때 실렉터(selector)의 라벨에 일치하는 파드를 etcd에서 조회하여 전송할 파드의 IP 주소를 취득

### 대표 IP 주소
- 서비스는 파드의 그룹을 대표하여 클라이언트의 요청을 받기 위해 대표 IP 주소(ClusterIP)를 가짐
- headless로 지정한 경우에는 대표 IP 주소를 지정하지 않고, 파드의 IP 주소를 직접 내부 DNS에 설정

### 부하분산
- 서비스의 대표 IP 주소에 도착한 요청은 selector의 라벨과 일치하는 파드에 전송
- 이를 위한 모듈인 kube-proxy는 초창기에는 커널의 유저 공간에서 동작하는 프록시 서버였지만, 지금은 iptable나 ipvs를 관리하는 프로그램으로 바뀜

### 이름 해결
- 서비스는 IP 주소와 서비스명을 K8s 클러스터의 내부 DNS에 등록함
- K8s 클러스터의 내부 DNS에 등록함. K8s 클러스터 내의 파드에서는 서비스 이름으로 접근하는 것이 가능

### 환경 변수
- 서비스가 만들어지고 나서 생성되는 파드의 컨테이너에는 환경 변수가 설정되어 있음
- 컨테이너 안의 애플리케이션 코드에서는 환경 변수를 이용해서 서비스의 대표 IP 주소를 얻을 수 있음

### 서비스 타입
- 서비스를 설정할 때는 해당 서비스를 이용하는 클라이언트를 고려하여 서비스 타입을 지정
- K8s 클러스터 내부 파드를 대상으로 하는 경우와 K8s 클러스터 외부에서 접근하는 경우를 고려하여 지정

### 어피니티
- 기본적으로 부하분산에 사용되는 알고리즘은 랜덤. 클라이언트에 따라 전송되는 파드를 고정하고 싶은 경우에는 sessionAffinity 항목에 ClientIP를 설정함
- HTTP 헤드 안의 쿠키(Cookie) 값에 따라 전송되는 파드를 고정하고 싶은 경우에는 뒤에서 설명할 인그레스를 이용해야 함

### 실렉터와 라벨
- 서비스에 실렉터(selector)와 라벨을 참조. 라벨은 파드 등의 오브젝트에 부여하는 키값 쌍
- 서비스에 도착한 요청은 실렉터에 설정된 조건에 일치하는 라벨을 가지는 파드에 전송. 
- 실렉터의 라벨 조건이나 파드에 부여되는 라벨은 운영 중에도 바뀔 수 있어 유연하게 운영 가능

## 컨트롤러의 기본
- 컨트롤러는 파드를 제어. 파드에게 부여할 워크로드의 타입. 즉 처리에 따라서 적절한 컨트롤러를 선택해야 함  

![img](https://github.com/koni114/TIL/blob/master/container/docker/img/docker_18.png)

### 워크로드 타입
#### 프론트엔드 처리
- 스마트폰, IOT 기기, 컴퓨터 등의 클라이언트로부터 요청을 직접 받아드리는 워크로드를 총칭
- 이 타입의 워크로드는 대량의 클라이언트 요청에 대해 짧은 시간에 응답을 반환하는 것이 중요
- 이러한 워크로드 특성에 대응하여 요청에 대응하는 처리를 복수의 파드에서 분담하도록 설계해야함
- 24시간 무정지로 서비스를 제공하면서도 빠르게 신기능을 배포할 수 있어야 함 

#### 백엔드 처리
- 요청량이 변하더라도 일정한 응답 속도를 유지해야 함
- 요구 사항에 맞게 단기간에 기능을 추가하고 변경하는 것이 가능해야 함
- 백엔드 처리에서는 보통 MySQL이나 Redis와 같은 미들웨어를 사용하거나 클라우드 사업자가 제공하는 데이터베이스 관리 서비스를 활용  
  다음과 같은 워크로드들이 있음
  - 데이터 스토어: 데이터의 보존과 조회 기능(SQL/NoSQL 데이터베이스 등)  
  - 캐시: 복수 파드에서 데이터 공유(세션 정보 공유 등)
  - 메시징: 비동기 시스템 간 연계 기능(메세지 브로커)
  - 마이크로 서비스: 전문적 업무 기능 구현(결제, 배송, 결제 승인 등)
  - 배치 처리: 긴 처리 시간을 요하는 업무 기능(기계 학습, 데이터 분석)

#### 배치 처리(정기 실행 처리 포함)
- 배치 처리는 어떤 트리거에 의해 실행이 게시됨
- 프런트엔드로부터의 요청, 정해진 시간, 단말로부터의 수시 요청 등에 의해 개시

#### 시스템 운영 처리
- 시스템 운영을 돕기 위해 쿠버네티스 API를 사용해서 노드에서 발생하는 에러나 하드웨어 이상을 감지, 자동으로 대책을 실행하는 파드를 만드는 경우가 있음

### 컨트롤러의 타입
- 컨트롤러는 앞에서 살펴본 다양한 워크로드를 처리하기 위해 파드를 제어하고 실행하는 역할 담당  
  대표적인 컨트롤러 7개의 역할과 특징

#### 디플로이먼트(Deployment)
- 대등한 관계에 있는 여러 개의 파드로 수평한 클러스터를 구성할 때 사용
- 정해진 개수만큼 파드가 기동하도록 관리. 가동 중인 파드를 차례대로 교체하거나 규모를 조절할 수 있는 기능을 갖추고 있음

#### 스테이트풀셋(StatefulSet)
- 파드와 퍼시스턴트 볼륨을 조합하여 <b>데이터의 보관</b>에 초점을 둔 컨트롤러
- 파드와 퍼시스턴트 볼륨에 번호를 매겨 관리함으로써 본질적으로 일시적인 존재인 파드가 상태를 가지는 워크로드를 처리할 수 있도록 해줌

#### 잡(Job)
- 배치 처리를 하는 컨테이너가 정상 종료 할 때까지 재실행을 반복하는 컨트롤러
- 파드 실행 횟수, 동시 실행수, 실행 횟수의 상한을 설정할 수 있음. 지워질 때까지 로그를 보존. 데이터 처리나 과학 분야의 계산 작업 등에 사용

#### 크론잡(CronJob)
- 지정한 시각에 정기적으로 앞서 소개한 잡을 생성. cron과 같은 형식으로 잡의 생성 시각을 설정할 수 있음
- Job을 실행 완료한 파드를 몇 개까지 보관할 수 있는지 설정할 수 있음  
  정기적으로 실행되어야 하는 배치 처리에 적합

#### 데몬셋(DaemonSet)
- K8s 클러스터의 모든 노드에서 같은 파드를 실행하기 위해 존재
- 예를 들어 클러스터 네트워크를 구성하는 파드는 데몬셋에 의해 모든 노드에서 실행되며, 새로운 노드가 추가되면 해당 노드에서 자동으로 실행됨. 시스템 운영의 자동화에 적합

#### 레플리카셋(ReplicaSet)
- 디플로이먼트 컨트롤러와 연동해서 파드가 기동되어야 하는 수를 관리
- 레플리카셋은 직접 다루기보다는 디플로아먼트를 통해 이용하는 것이 기본

#### 레플리케이션 컨트롤러(Replication Controller)
- 쿠버네티스의 예전 튜토리얼 등에서 언급되는데 차세대 컨트롤러인 디플로이먼트로 대체됨

### 워크로드와 컨트롤러의 대응
- 아래의 표의 내용은 워크로드와 컨트롤러의 대응 관계이며, 이는 하나의 예에 불과하며, 다르게 작용할 수도 있음

| 워크로드 타입 | 컨트롤러 타입 |
| --- | --- |
| 프런트엔드 처리 | 디플로이먼트 |
| 백엔드 처리 | 스테이트풀셋 |
| 배치 처리 | 잡 크론잡 |
| 시스템 운영 | 데몬셋 |

- CPU 코어 수를 늘리거나, 메모리 증설 등의 노드 스케일 업과 같은 기능은 컨트롤러가 제공하지 않음
- 이러한 노드 스케일 업은 클라우드에서의 경우, 보다 많은 CPU 코어 수나 메모리 용량을 탑재한 노드를 준비하여 K8s 클러스터에 추가한 후, 파드의 노드 셀렉터를 설정해서 마이그레이션 해야 함



## 참고: 멀티 노드 k8s 클러스터를 PC에 구축
- 학습 환경 2에서는 CNCF의 쿠버네티스 프로젝트가 배포하는 업스트림 코드를 사용하여 PC에서도 동작하는 소규모 멀티 노드 쿠버네티스 클러스터 환경을 구축
- 가상 환경 구축은 `Vagrant`, `Ansible` 사용. 이번 절에서 사용할 코드들은 github 저장소에 저장되어 있음
- 다음 그림은 구성할 환경의 소프트웨어 스택. 자동화 도구(Vagrant, Ansible)에 의해 음영 부분에 해당되는 소프트웨어들이 자동으로 설치됨

![img](https://github.com/koni114/TIL/blob/master/container/docker/img/docker_09.png)

- 다음은 표 1에 PC 환경, 표 2에 설치할 소프트웨어, 표 3에 도커와 쿠버네티스의 버전, 표 4에는 가상 NFS 서버를 설치하기 위해 필요한 스펙 정리. 


### 표1
|     |     |
| --- | --- |
| 필요 항목 | 조건  |
| PC 하드웨어 | Windows PC 또는 MAC |
| CPU | Intel Core i5 이상, 가상화 지원 기능(VT) |
| RAM(메모리) | 최소 8GB, 추천 16GB |
| 운영체제 | macOS High Sierra 버전 10.13 이상<br>Windows 10 버전 1803 이상 64bit |
| 인터넷 환경 | 브로드밴드 접속 환경(50Mbps 이상) |

### 표2
| OS  | 패키지 | 최저 버전 |
| --- | --- | --- |
| Windows 10 | virtualbox | 5.2.8 |
|     | Vagrant | 2.1.2 |
|     | git | 2.9.0 |
| MacOS | virtualBox | 5.1.10 |
|     | Vagrant | 2.0.3 |
|     | git | 2.17.0 |

### 표3
| 소프트웨어 | 조건  |
| --- | --- |
| 리눅스 | Ubuntu16.04 LTS x86_64 |
| 도커  | Community Edition 버전 18.06.1-ce |
| 쿠버네티스 | 버전 1.14.0 |

### 표4
| 노드  | 항목  | 요건  |
| --- | --- | --- |
| 마스터 | 호스트 이름 | master |
|     | 리눅스 | ubuntu 16.04 LTS x86_64 |
|     | Host Only(Private) IP 주소 | 172.16.20.11 |
|     | vCPU | 2   |
|     | 메모리 | 1GB |
| Node #1 | 호스트 이름 | node1 |
|     | 리눅스 | ubuntu 16.04 LTS x86_64 |
|     | Host Only(Private) IP 주소 | 172.16.20.12 |
|     | vCPU | 1   |
|     | 메모리 | 1GB |
| Node #2 | 호스트 이름 | node2 |
|     | 리눅스 | ubuntu 16.04 LTS x86_64 |
|     | Host Only(Private) IP 주소 | 172.16.20.13 |
|     | vCPU | 1   |
|     | 메모리 | 1GB |


## 용어 정리
- 업스트림
  - 클라이언트나 로컬 컴퓨터에서 서버나 원격 호스트로 데이터를 보내는 것을 말함
  - 업스트림 전송은 여러 형태를 취할 수 있으며, 데이터가 로컬 시스템에서 서버로 전송되는 속도를 업스트림 속도라고 함
  - <b>쿠버네티스에서는 코어 쿠버네티스(포크된 저장소)를 의미함. 보편 생태계, 다른 코드, 서드파티 도구에 의존하는 코어 쿠버네티스 코드베이스를 의미</b>
  - 책 저자는 <b>클라우드 업체나 솔루션 업체가 손대지 않은 상태를 의미한다고 말함</b>
- NFS
  - Network File System
  - 옛날에는 서버하나만 구축해도 많은 공간을 차지하여 클라이언트들은 여유 공간이 없었음
  - 그래서 개발한 것이 클라이언트가 서버의 공간을 자신의 자원처럼 사용이 가능하게 만듬  
  - 네트워크 상에 연결된 다른 컴퓨터의 하드 디스크를 내 컴퓨터의 하드처럼 사용하는 것
  - 네트워크에 연결된 리눅스끼리 NFS를 통해 파일을 공유 가능
- CNCF ( Cloud Native Computing Foundation )
  - 리눅스 재단 소속의 비영리 단체 
- 엔드포인트
  - 서비스를 사용가능하도록 하는 서비스에서 제공하는 커뮤니케이션 채널의 한쪽 끝
  - 홈페이지라면 일반 유저, 라이브러리나 프레임워크라면 사용할 개발자 정도로 생각할 수 있음
- 데몬(daemon)
  - 사용자가 직접적으로 제어하지 않고 백그라운드에서 돌면서 여러 작업을 수행하는 프로그램
  - 시스템 로그를 남기는 syslogd처럼 보통 데몬을 뜻하는 `d`를 이름 끝에 달고 있으며, 일반적으로 프로세스로 실행됨 
- 에이전트(Agent)
  - 특정 목적에 대해 사용자를 대신하여 작업을 수행하는 자율적인 프로세스
  - 데몬(Daemon)과 에이전트(Agent)의 차이점은 사용자의 입력 여부에 의해서 구분할 수 있음  
    데몬 같은 경우는 사용자의 입력 없이 백그라운드에서 작업을 수행하여 에이전트는 사용자의 입력이나 사용자가 주어진 목적을 달성하기 위해 수행
- OSS
  - Open Source software
